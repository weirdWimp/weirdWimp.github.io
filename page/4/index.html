<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>The Cabin in the City</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                About
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">'s Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/Vim%20Editiong%20Basics/">Vim Editiong Basics</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2022-06-03</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h1 id="Editing-Basics"><a href="#Editing-Basics" class="headerlink" title="Editing Basics"></a>Editing Basics</h1><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>当你编辑一个文件时， Vim 将磁盘上的文件内容读取到计算机的 RAM 中. 这意味这文件的一个备份被存储到了计算机的内存中，你对文件做出的任何修改，是直接映射到内存中的，并且会立即展示出来. 一旦完成了编辑，你可以保存文件，这意味着 Vim 将内存中的内容要写回磁盘. 临时存储文件的内存被称为缓存  (<strong>Buffer</strong>) .  所以，这就是为什么编辑完后要保存文件的原因.</p>
<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>当你编辑文件时, 会在相同目录下会创建一个类似于 <code>.hello.txt.swp</code> 的文件. 查看确切的文件名可以使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:swapname</span><br></pre></td></tr></table></figure>

<p> Vim 维护了文件缓存区 (buffer) 的一个文件备份, 会定期保存到该文件中, 以避免出现问题时进行恢复 (如 计算机或者 Vim 程序崩溃).  这个文件被称为 <code>swap file</code>, 因为 Vim 会不断交换内存中的内容到磁盘上的文件中.</p>
<h3 id="Save-my-file"><a href="#Save-my-file" class="headerlink" title="Save my file"></a>Save my file</h3><p>当你修改了文件时, 并且没有保存, 在另一个窗口查看时, 此时是不会看到之前修改的内容的, 这也很好理解, 因为 Vim 只修改了 buffer 中的内容, 还没有保存到磁盘上. 可以通过  <code>:write</code> 命令来完成保存过程, 将内存中的内存写到磁盘中.</p>
<p><strong>为了让生活变得容易一点, 你可以使用快捷键映射, 在 vimrc 文件中:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#To save,ctrl-s.</span></span><br><span class="line">nmap &lt;c<span class="_">-s</span>&gt; :w&lt;CR&gt;</span><br><span class="line">imap &lt;c<span class="_">-s</span>&gt; &lt;Esc&gt;:w&lt;CR&gt;a</span><br></pre></td></tr></table></figure>



<h3 id="Cut-Copy-and-paste"><a href="#Cut-Copy-and-paste" class="headerlink" title="Cut, Copy and paste"></a>Cut, Copy and paste</h3><table>
<thead>
<tr>
<th>desktop</th>
<th>vim word</th>
<th>operation</th>
</tr>
</thead>
<tbody><tr>
<td>cut</td>
<td>delete</td>
<td>d</td>
</tr>
<tr>
<td>copy</td>
<td>yank</td>
<td>y</td>
</tr>
<tr>
<td>paste</td>
<td>put</td>
<td>p</td>
</tr>
</tbody></table>
<p>剪切操作在 Vim 中意味着从 buffer 中删除文本, 并将其存储到寄存器中</p>
<p>复制操作中同样也意味着拉取 (yank) 文本,并将其放到寄存器中</p>
<p>粘贴没有其特殊含义</p>
<p><strong>Why yank not copy ?</strong></p>
<blockquote>
<p><strong>Yanking is just a Vim name for copying.  The “c” letter was already used for the change operator, and “y” was still available.  Calling this operator “yank” made it easier to remember to use the “y” key.</strong></p>
<p>– Vim User Manual</p>
</blockquote>
<h4 id="如何在-Vim-中指定要在哪些文本上应用-cut-copy-paste-操作"><a href="#如何在-Vim-中指定要在哪些文本上应用-cut-copy-paste-操作" class="headerlink" title="如何在 Vim 中指定要在哪些文本上应用 cut/copy/paste 操作?"></a>如何在 Vim 中指定要在哪些文本上应用 cut/copy/paste 操作?</h4><p>你可以:</p>
<table>
<thead>
<tr>
<th>command</th>
<th>operation</th>
</tr>
</thead>
<tbody><tr>
<td>dl</td>
<td>删除单个字符</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词</td>
</tr>
<tr>
<td>dd</td>
<td>删除一行</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标位置到行尾的所有字符</td>
</tr>
<tr>
<td>dwwP</td>
<td>交换两个单词</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p><strong>是不是很棒, 这里最让人激动的事情在于, 你可以结合之前的移动等命令, 更多的可能不是吗?  一般的编辑器, 可能没有办法做到如此简洁, 有力 , 并保持方便记忆 !</strong></p>
<p>还记得清空当前文档的操作吗 ?</p>
<h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><ul>
<li><code>w</code></li>
<li><code>e</code></li>
</ul>
<h3 id="Sentence"><a href="#Sentence" class="headerlink" title="Sentence"></a>Sentence</h3><ul>
<li><code>(</code></li>
<li><code>)</code></li>
</ul>
<h3 id="Paragraph"><a href="#Paragraph" class="headerlink" title="Paragraph"></a>Paragraph</h3><ul>
<li><code>{</code></li>
<li><code>}</code></li>
</ul>
<h3 id="Visual-Mode-Select"><a href="#Visual-Mode-Select" class="headerlink" title="Visual Mode Select"></a>Visual Mode Select</h3><ul>
<li><p><code>aw</code></p>
<p> select a word</p>
</li>
<li><p><code>ap</code></p>
<p>select a paragraph</p>
</li>
<li><p><code>ab</code></p>
<p>select a block (anything with a pair of parentheses)</p>
</li>
<li><p><code>a&quot;</code></p>
<p>select a quoted string (like “this is a quoted string”)</p>
</li>
</ul>
<h3 id="Marking-your-territory"><a href="#Marking-your-territory" class="headerlink" title="Marking your territory"></a>Marking your territory</h3><ul>
<li><p>create a mark where you can jump here later</p>
<p><code>ma</code> (a-zA-Z ) then you create a mark called ‘a’</p>
</li>
<li><p>return the cursor to the mark</p>
<p><code>&#39;a</code> take you to the exact line and column of the mark</p>
</li>
</ul>
<h3 id="Time-machine-using-undo-redo"><a href="#Time-machine-using-undo-redo" class="headerlink" title="Time machine using undo/redo"></a>Time machine using undo/redo</h3><ul>
<li><p><code>u</code> undo  :leftwards_arrow_with_hook:</p>
</li>
<li><p><code>ctrl-r</code> redo :arrow_right_hook:</p>
</li>
<li><p>more…</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># take you back by 4 minutes</span></span><br><span class="line">:earlier 4m</span><br><span class="line"></span><br><span class="line"><span class="comment"># take you later by 45 seconds</span></span><br><span class="line">:later 45s</span><br><span class="line"></span><br><span class="line"><span class="comment"># go back 5 changes</span></span><br><span class="line">undo 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># view the undo tree</span></span><br><span class="line">undolist</span><br></pre></td></tr></table></figure>



<h3 id="Powerful-search-engine"><a href="#Powerful-search-engine" class="headerlink" title="Powerful search engine"></a>Powerful search engine</h3><ul>
<li>basic search*</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search</span></span><br><span class="line">/the&lt;cr&gt; <span class="comment"># /the followed by the enter key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># next occurrence</span></span><br><span class="line">press `n`</span><br><span class="line"></span><br><span class="line"><span class="comment"># previous occurrence</span></span><br><span class="line">press `N`</span><br></pre></td></tr></table></figure>

<p>  还记得我们第一次介绍 Vim 的骚操作吗 <code>*</code> 搜索当前光标所在的单词</p>
<ul>
<li>start searching as and when you type the search phrase</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> incsearch</span><br></pre></td></tr></table></figure>

<ul>
<li>ignore the case of the text that you are searching for</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ignorecase</span><br></pre></td></tr></table></figure>

<ul>
<li>smart case</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> smartcase</span><br></pre></td></tr></table></figure>

<ul>
<li>searching for <code>/step</code>, then it will search for any combination of upper and lower case text. So eventually, “Step”, “Stephen”,”stepbrother”</li>
<li>searching for <code>/Step</code>, <strong>only</strong> “Step”, “Stephen”, but not “stepbrother”</li>
</ul>
<ul>
<li>basic patterns</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exactly search the word 'step' and not 'stepfather'</span></span><br><span class="line">/\&lt;step\&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># search numbers</span></span><br><span class="line">/\d\+</span><br><span class="line"></span><br><span class="line"><span class="comment"># see :help pattern for more details</span></span><br></pre></td></tr></table></figure>



<p><strong>永远不要去死记硬背这些操作, 试着理解, 并练习, 最终成为肌肉记忆.</strong></p>
<p><a href="http://vimdoc.sourceforge.net/htmldoc/usr_04.html" target="_blank" rel="noopener">vim doc</a></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/Vim%20Powerful%20Commands/">Vim Powerful Commands</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2022-05-29</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Vim-Versatile-commands"><a href="#Vim-Versatile-commands" class="headerlink" title="` Vim Versatile commands"></a>` Vim Versatile commands</h2><ul>
<li><p><code>.</code></p>
<ul>
<li><p>通过 Normal Mode （命令行模式）下的 <code>.</code> 命令来重复上一次的修改操作. 上一次的修改意味着很多操作：Normal Mode 下删除一个或多个字符，单词，行， 如 <code>x</code>, <code>dw</code>, <code>d$</code>, <code>dd</code> 等；比如改变缩进的命令：<code>&gt;&gt;</code>, <code>&lt;&lt;</code> 等. </p>
</li>
<li><p>命令行模式下大多数命令对文本做出的修改，都可以使用 <code>.</code> 来重复；Insert Mode （编辑模式） 下做出的修改的重复取决于进入该模式的命令，加入，你通过 <code>A</code> 进入 Insert Mode, 在末尾添加了单词 <code>end</code>，按下 <code>Esc</code>,  <code>.</code> 命令会在末尾重复添加单词 <code>end</code>.</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. You are now in Normal Mode, you have the text like those below:</span></span><br><span class="line"></span><br><span class="line">This is </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Press A to enter Insert Mode and write text `end`</span></span><br><span class="line">This is end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Press Esc to enter Normal Mode and press .(period), things will happen like this:</span></span><br><span class="line">This is end end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. mode dot, mode ` end`</span></span><br><span class="line">This is end end end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>5.</code> 表示重复执行多少次</li>
<li>Motions (光标的移动) 并不会改变任何事情，所以 <code>.</code> 并不会进行重复</li>
</ul>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Redis/Redis%20Cluster/">Redis Cluster</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-12-04</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Redis/">Redis</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>consistent hashing 一致性哈希</p>
<p>hash slot 哈希槽</p>
<h2 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h2><p>Redis 集群没有使用一致性哈希，而是使用了一种不同的数据分片形式: 每个键在概念上属于所谓的 <strong>哈希槽</strong> (hash slot) 的一部分。Redis 集群一共有 16384 个哈希槽，计算一个给定键的哈希槽，采取的方式是：<strong>键的 CRC16 对 16384 取模</strong>。</p>
<p>Redis 集群中的每一个节点都负责所有哈希槽的一个子集. 假如一个集群有三个节点，那么哈希槽的分布可能是这样:</p>
<ul>
<li>A 节点的哈希槽范围 0 - 5500</li>
<li>B 节点的哈希槽范围 5501 - 11000</li>
<li>C 节点的哈希槽范围 11001 - 16383</li>
</ul>
<p>这使得很容易在集群中增加和移除节点。例如，如果想增加一个新节点 D, 需要将 A,B,C 中的某些哈希槽移动到 D. 类似的，如果想要移除节点 A, 可以将 A  负责的哈希槽移动到 B 和 C。</p>
<p>由于从一个节点向另一个节点移动哈希槽并不需要停止操作，增加和移除节点或者改变节点所负责的哈希槽的百分比，不需要任何的宕机操作。</p>
<p>Redis 集群支持多个键的操作（多个键的同时操作），只要单个命令的执行（Redis事务，Lua脚本执行）所涉及的这些键，都属于同一个哈希槽。用户可以通过使用一个叫做 <strong>哈希标签</strong>  (hash tags) 的概念，强制多个键属于不同的哈希槽.</p>
<p>Redis 集群规范中记录了哈希标签，但重点是，如果键中的 <code>{}</code> 括号之间有一个子字符串，则仅对字符串内的内容进行哈希处理，例如 <code>this{foo}key</code> 和 <code>another{foo} key</code> 保证在同一个哈希槽中，并且可以在一个命令中一起使用多个键作为参数。</p>
<h2 id="Redis-集群的主复制模式"><a href="#Redis-集群的主复制模式" class="headerlink" title="Redis 集群的主复制模式"></a>Redis 集群的主复制模式</h2><p>Redis Cluster master-replica model</p>
<p>为了保证可以用性, 当主节点中的某些节点出现故障或者不能与集群中的大多数节点进行通信时, Redis 集群使用了一种主节点复制模式, 即每个哈希槽都有一个到 N 个副本 (N-1 个额外的副本节点).</p>
<p>在上述 A, B, C 三个节点的集群中, 如果节点 B 故障, 集群不能与之通信, 那么就不再能够提供哈希槽 0-5500 范围的服务. 然而, 如果在创建集群的时候, 为每一个主节点增加一个副本节点, 那么最终集群包含了 A, B, C 以及对应的副本节点 A1, B1, C1. 这样, 系统就能够在 B 节点故障时继续提供服务.</p>
<p>B1 节点复制节点 B, 如果 B 节点故障, 集群将使得 B1 成为新的主节点继续正确地提供服务. 但是如果 B1 和 B 同一时间都故障了, 那么集群就不能继续服务.</p>
<h2 id="Redis-集群地一致性保障"><a href="#Redis-集群地一致性保障" class="headerlink" title="Redis 集群地一致性保障"></a>Redis 集群地一致性保障</h2><p>Redis Cluster consistency guarantees</p>
<p>Redis Cluster 无法保证强一致性。实际上，这意味着在某些条件下，Redis Cluster 可能会丢失系统已向客户端确认的写入。</p>
<p>Redis Cluster 会丢失写入的第一个原因是因为它使用异步复制。这意味着在写入期间会发生以下情况：</p>
<p>客户端写入主 B。<br>主 B 向客户端回复 OK。<br>主 B 将写入传播到其副本 B1、B2 和 B3。</p>
<p>B 在回复客户端之前不会等待来自 B1、B2、B3 的确认，因为这对 Redis 来说是一个令人望而却步的延迟惩罚，因此如果您的客户端写入某些内容，B 会确认写入，但会在此之前崩溃能够将写入发送到其副本，其中一个副本（未收到写入）可以提升为主，永远失去写入。</p>
<p>这与大多数配置为每秒将数据刷新到磁盘的数据库发生的情况非常相似，因此您已经能够推理出这种情况，因为过去使用不涉及分布式系统的传统数据库系统的经验。同样，您可以通过强制数据库在回复客户端之前将数据刷新到磁盘来提高一致性，但这通常会导致性能低得令人望而却步。在 Redis Cluster 的情况下，这相当于同步复制。</p>
<p>基本上，需要在性能和一致性之间进行权衡。</p>
<p>Redis 集群在绝对需要时支持同步写入，通过 WAIT 命令实现。这使得丢失写入的可能性大大降低。但是请注意，即使使用同步复制，Redis Cluster 也没有实现强一致性：在更复杂的故障场景下，始终有可能将无法接收写入的副本选为 master。</p>
<p>还有一个值得注意的场景是 Redis 集群将丢失写入，这发生在网络分区期间，客户端与少数实例（至少包括一个主实例）隔离。</p>
<p>以我们的 6 个节点集群为例，它由 A、B、C、A1、B1、C1 组成，有 3 个主节点和 3 个副本节点。还有一个客户端，我们将其称为 Z1。</p>
<p>分区发生后，可能在分区的一侧有 A、C、A1、B1、C1，而在另一侧有 B 和 Z1。</p>
<p>Z1 仍然能够写入 B，B 将接受其写入。如果分区在很短的时间内愈合，集群将继续正常运行。但是，如果分区持续足够的时间让 B1 在分区的多数侧提升为 master，则 Z1 同时发送给 B 的写入将丢失。</p>
<p>请注意，Z1 能够发送到 B 的写入量有一个最大窗口：如果分区的多数方已经有足够的时间来选举一个副本作为主节点，那么少数方的每个主节点都将停止接受写入。</p>
<p>这个时间量是Redis Cluster一个非常重要的配置指令，称为节点超时。</p>
<p>节点超时后，主节点被视为出现故障，并且可以由其副本之一替换。类似地，在节点超时过后，主节点无法感知大多数其他主节点，它会进入错误状态并停止接受写入。</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Redis/Redis%20%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/">Redis 的持久化</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-11-21</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Redis/">Redis</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h1 id="Redis-数据持久化"><a href="#Redis-数据持久化" class="headerlink" title="Redis 数据持久化"></a>Redis 数据持久化</h1><p>Redis 中，有两种方式将数据持久化到磁盘。一种称之为<strong>快照</strong> (Spapshotting), 将某一时刻存在数据写道磁盘。另外一种称之为<strong>AOF 仅追加文件</strong> (append-only file), 它是将到来的所有写命令写到磁盘上。这两种方式可以一起使用，也可以单独使用，或者不适用持久化。</p>
<p>选择配置数据持久话的原因还是为了在 Redis，Redis 所在的主机硬件等发生故障时进行恢复，可以将持久化的文件在远程主机进行备份，故障时进行恢复。而且，如果 Redis 中的数据时大数据集上的聚合分析结果，没有备份，重新计算的代价可能时无法接受的。</p>
<h2 id="通过快照将数据持久化到磁盘"><a href="#通过快照将数据持久化到磁盘" class="headerlink" title="通过快照将数据持久化到磁盘"></a>通过快照将数据持久化到磁盘</h2><p>在 Redis 中，可以通过创建一个快照，创建一个内部中数据的某个时刻的副本，这些副本可以被备份，复制到其它服务器，创建一个 Redis 服务器的副本，或者留着待以后重启使用。</p>
<h3 id="基本的配置选项"><a href="#基本的配置选项" class="headerlink" title="基本的配置选项"></a><strong>基本的配置选项</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000 <span class="comment"># 创建快照的频率。如果自上一次创建快照后的 60s 内有 1000 此写，就开启新的快照</span></span><br><span class="line">stop-writes-on-bgsave-error no <span class="comment"># 当创建快照时，发生异常是否暂停所有的写命令</span></span><br><span class="line">rdbcompression yes   <span class="comment"># 是否进行压缩</span></span><br><span class="line">dbfilename dump.rdb  <span class="comment"># 快照文件名</span></span><br><span class="line"></span><br><span class="line">dir ./ <span class="comment"># 快照文件保存的目录</span></span><br></pre></td></tr></table></figure>

<p>自上一次快照完成后，直到下一次快照开始执行，这个期间，如果 Redis 崩溃，系统或硬件故障，期间的写数据就会丢失。</p>
<h3 id="五种初始化快照的方法"><a href="#五种初始化快照的方法" class="headerlink" title="五种初始化快照的方法"></a>五种初始化快照的方法</h3><ol>
<li><p>任何的 Redis 客户端都可以通过调用 <code>BGSAVE</code> 命令来初始化快照（创建快照）。在所有支持 <code>BGSAVE</code>  的平台上，Redis 会进行进程的 <strong><em>fork</em></strong>, 子进程会将快照写到磁盘，而父进程仍然可以用于响应来自客户端的命令。</p>
<blockquote>
<p>当一个进程 fork 时，底层的操作系统会创建该进程的一个副本。在 Unix 和类 Unix 的系统上，复制进程会被优化：最开始，子进程和父进程时共享所有内存的。当父进程或子进程开始写内存，内存将不再共享。</p>
</blockquote>
</li>
<li><p>Redis 的客户端可以通过调用 <code>SAVE</code> 命令来初始化快照，这将导致 <strong>Redis 停止对任何命令的响应</strong>，直到快照完成。不经常使用，但是如果对于该这种等待 ok 或者没有足够的内存执行 <code>BGSAVE</code> 操作，可以使用。</p>
</li>
<li><p>如果 Redis 配置了 <code>save</code> 选项，如 <code>save 60 10000</code>， 如果自上一次快照成功后的 60s 内，已经有 10000 个写操作，那么 Redis 会自动触发一个 <code>BGSAVE</code> 操作。可以配置多个 <code>save</code> 行，任意一条规则满足，就会触发 <code>BGSAVE</code> 操作。</p>
</li>
<li><p>当 Redis 接受到 <code>SHUTDOWN</code> 终止命令时，或者接受到标准的 <code>TERM</code> 信号，Redis 会执行 <code>SAVE</code> 操作，阻塞任何客户端执行任何命令，然后再终止。</p>
</li>
<li><p>当一个 Redis 服务器连接到另一个 Reids 服务器，并且发起了 <code>SYNC</code> 同步命令开始复制（replication）, Master Redis 服务器将会开始一个 <code>BGSAVE</code> 操作，如果当前没有一个正在进行中的 <code>BGSAVE</code> 操作或者最近完成了。</p>
</li>
</ol>
<h2 id="只追加写文件持久化-Append-only-file-persistence"><a href="#只追加写文件持久化-Append-only-file-persistence" class="headerlink" title="只追加写文件持久化 (Append-only file persistence)"></a>只追加写文件持久化 (Append-only file persistence)</h2><p>只追加写文件通过将修改写到文件的末尾，保存了数据发生修改时的记录。这样，任何人都有可以通过从头到尾，重放 (replay) 只追加写日志文件就可以恢复整个数据集。可以通过设置配置项 <code>appendonly yes</code> 开启。</p>
<h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><p>当写文件到磁盘上时，至少发生了三件事：首先是写缓存，当调用 <code>file.write()</code> 或其它语言中等价的命令时会执行该操作。当数据存在缓冲区中时，操作系统可以将这些数据再未来的某个时刻写到磁盘。可以通过调用 <code>file.flush()</code>, 要求操作系统将数据写到磁盘上，但这只是发给操作系统的一个请求，并不会立即执行。由于数据实际时不在磁盘上的直到操作系统将它写到磁盘上，我们可以告诉操作系统<strong>同步</strong>文件到磁盘上，这将导致阻塞 (block)，直到同步完成。当同步完成时，我们可以确定数据此时是在磁盘上的，并且如果系统故障，可以稍后读取进行恢复。</p>
<h4 id="appendfsync-always"><a href="#appendfsync-always" class="headerlink" title="appendfsync always"></a><code>appendfsync always</code></h4><p>如果设置了 <code>appendfsync always</code>, Redis 的每次写将会导致一个磁盘的写过程，如果 Reid 崩溃了，这可以极大地减少数据丢失。然而，因为每次都有写磁盘这个过程，整体的性能会受限于此磁盘的性能。</p>
<h4 id="appendfsync-eversec"><a href="#appendfsync-eversec" class="headerlink" title="appendfsync eversec"></a><code>appendfsync eversec</code></h4><p>作为保持数据安全和保持高写入性能之间的合理折衷，我们还可以设置 appendfsync everysec。 此配置将每秒同步一次仅追加日志文件。 对于大多数常见用途，与不使用任何类型的持久性相比，我们可能不会发现每秒同步到磁盘的显着性能损失。 通过每秒同步到磁盘，如果系统崩溃，我们最多可能会丢失一秒钟已在 Redis 中写入或更新的数据。 此外，在磁盘无法跟上正在发生的写入量的情况下，Redis 会优雅地减速以适应驱动器的最大写入速率。</p>
<h4 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a><code>appendfsync no</code></h4><p>Redis 并不会显示地执行任何文件同步，而是将这一切交给操作系统。这种情况下应该没有性能损失，但如果系统以某种方式崩溃，我们将丢失未知和不可预测的数据量。 如果我们使用的硬盘驱动器对于我们的写入负载来说不够快，Redis 会运行良好，直到将数据写入磁盘的缓冲区被填满，此时 Redis 会因为被阻止写入而变得非常慢。 通常不鼓励使用此配置选项。</p>
<h3 id="重写-压缩-AOF"><a href="#重写-压缩-AOF" class="headerlink" title="重写/压缩 AOF"></a>重写/压缩 AOF</h3><p>AOF 看起来比较完美，即能将数据损失降低到 1s，又可以最小化数据持久化到磁盘上地时间。但是问题是，Redis 的每次写命令，都会生成一条日志记录，随着时间的推移，AOF 日志文件的大小会不断增长，可能会导致磁盘空间耗尽。但更常见的问题是，在 Redis 重启时，由于需要按顺序执行 AOF 中的每条命令，处理较大的文件，需要花费更长的时间</p>
<p>此时可以使用 <code>BGREWRITEAOF</code>, 它会通过移除冗余的命令，来尽可能地使得 AOF 变得更小一点。和 <code>BGSAVE</code> 命令一样，这个命令也会执行一次 fork 过程，由子进程完成 AOF 的重写，所以关于 fork 的时间，内存使用的问题，同样也适用于 <code>BGREWRITEAOF</code>。而且更糟的时，当 AOF 被重写，操作系统需要删除几十 G 的 AOF 文件时，会使的操作系统中断几秒。</p>
<p>当启用 AOF , 并且满足以下两个配置项时，Redis 会启动一次 <code>BGREWRITEAOF</code>， 如果 AOF 重写的频率过高，可以适当增加 <code>auto-aof-rewritepercentage</code>， 但是可能会导致 Redis 启动需要花费更多的时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 AOF 至少比 Redis 上次完成重写时的 AOF 大 100% 时</span></span><br><span class="line">auto-aof-rewritepercentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 AOF 的大小至少为 64m 字节时</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>



<h2 id="复制-Replication"><a href="#复制-Replication" class="headerlink" title="复制 Replication"></a>复制 Replication</h2>
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Redis/Redis%20Transaction/">Redis Transaction</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-11-17</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Redis/">Redis</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="基础-Redis-事务"><a href="#基础-Redis-事务" class="headerlink" title="基础 Redis 事务"></a>基础 Redis 事务</h2><p>有时，需要在同一时间操作多个数据结构，这就需要进行多次 Redis 命令调用。虽然存在一些命令能够在 key 之间移动元素，但是并没有一个命令能够在不同类型的 key 之间移动元素（例外就是通过 <code>ZUNIONSTORE</code> 敏玲 复制一个 <code>SET</code> 到 <code>ZSET</code>）。对于涉及多个 key 的操作（无论是相同类型还是不同类型），Redis 提供了 5 个命令对多个 key 进行操作，且不需要中断：<code>WATCH</code>,  <code>MULTI</code>,<code>EXEC</code>, <code>UNWATCH</code>, <code>DISCARD</code>.</p>
<p><strong>Redis 最简单的事务就是使用 <code>MULTI</code> 和 <code>EXEC</code> 命令</strong>, 基础事务就意味着这两种命令提供了一种方式，<strong>使得一个客户端执行多个命令 A, B, C 时，不会被其它客户端打断</strong>，意思就是如果没有这种事务保证，A, B, C 命令一条一条执行时，执行完 A 命令，有可能其它客户端执行了 D 命令，然后这个客户端才去执行 B, A, B, C 的执行被打断了。这与关系数据库的事务时不同的，关系数据库的事务可以部分执行，然后回滚或是提交。在 Redis 中，作为 MULTI/EXEC 事务中一部分的每一个命令都是一个接一个执行的，直到所有命令全部完成，然后其它客户端才能执行它们的命令.</p>
<p><img src="https://raw.githubusercontent.com/weirdWimp/blog-store/main/img/image-20211117203044176.png" alt="image-20211117203044176"></p>
<p>要在 Redis 中之执行一个事务的步骤:</p>
<ol>
<li>首先调用 <code>MULTI</code> 命令</li>
<li>跟随一系列要执行的其它命令, Redis 会将该连接到来的这些命令存在队列中</li>
<li>执行 <code>EXEC</code> 命令, Redis 会顺序地执行 2 步骤中地所有命令,并且不会被中断</li>
</ol>
<p>语义上, Redis 的 Python 客户端库使用一种称之为管道 <code>popeline</code> 的方式处理这种事务,在一个连接对象上调用 <code>pipeline()</code> 方法会创建一个事务,使用正确的话, 会自动将一系列命令列封装在 <code>MULTI</code> 和 <code>EXEC</code>命令之间, 于此同时, Python 的客户端也会将要发送的命令存储起来,直到真正要送的时候, 才发送这些命令. 这能够减少 Redis 服务器与客户端的网络通信次数, 能够提高命令的执行效率, 提高性能.</p>
<p>如何验证 ? 可以通过多线程验证, 每个线程都是先对某个计数器 key 加 1, 再减 1, 非事务的情况下, 一个线程的 +1 和 -1 操作可能被其它 线程的 +1 和 -1 操作打断; 如果使用了 Redis 事务, 则不会出现这种情况。</p>
<p>其它客户端也是如此 ?</p>
<p> 使用事务的好处和坏处是什么？</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p><code>MULTI/EXEC</code> 这种基础事务的问题在于，如果没有执行 <code>EXEC</code> 命令，那么之前的任何命令都不会被执行， 这意味着不能利用中间一些读操作的结果来在程序中及时做出决策。</p>
<p><code>WATCH</code> 命令结合 <code>MULTI</code> 和 <code>EXEC</code> 命令， 以及 <code>UNWATCH</code> 和 <code>DISCARD</code> 命令，当通过 <code>WATCH</code> 命令关注 (watch) 键时，在执行 <code>EXEC</code> 操作前的任意时刻，这些键被其它客户端替换、更新或删除，那么这时尝试执行 <code>EXEC</code> 会失败，并返回错误信息。通过使用 <code>WATCH</code>, <code>MULTI/EXEC</code>, 以及 <code>UNWATCH/DISCARD</code> 命令可以确保在做一些重要的操作时，数据不会被修改。</p>
<p><strong>UNWATCH/DISCARD 的区别</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WATCH</span><br><span class="line">|</span><br><span class="line">|-----&gt; UNWATCH (reset the connection)</span><br><span class="line">|</span><br><span class="line">MULTI</span><br><span class="line">|</span><br><span class="line">|-----&gt; DISCARD (reset the connection: cancel the WATCH and clear out any queued commands)</span><br><span class="line">|</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>

<p>如果通过 <code>WATCH</code> 命令关注了一些 key， 然后通过 <code>MULTI</code> 命令开启了一个事务，并跟随了一组命令，这时可以通过 <code>DISCARD</code> 命令取消关注，并清除任何缓存的命令。</p>
<p><strong>客户端1操作</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get guoph2</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line">127.0.0.1:6379&gt; watch guoph2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> guoph2 3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="comment"># 在客户端2进行 set 后，执行 exec，本次事务执行失败，争产执行会返回 OK</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>客户端2操作</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get guoph2</span><br><span class="line"><span class="string">"2"</span></span><br><span class="line"><span class="comment"># 在客户端1操作 watch，multi,set命令后，对 key 的值进行更新</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> guoph2 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<p>结合 <code>WATCH</code> 与 <code>MULTI/EXEC</code> 命令，就可以在关注的键被其它客户端修改时得到通知，可以再次进行重试。</p>
<h3 id="为什么-Redis-不实现典型的锁机制"><a href="#为什么-Redis-不实现典型的锁机制" class="headerlink" title="为什么 Redis 不实现典型的锁机制"></a>为什么 Redis 不实现典型的锁机制</h3><p>当处于写数据的目的而访问数据时，即 SQL 中的 SELECT FOR UPDATE, 关系型数据库会对要访问的行进行加锁，直到一个事务通过 <code>COMMIT</code> 或者 <code>ROLLBACK</code>完成事务的处理. 如果其它客户端尝试对相同的行，access data for writing 时，其它客户端会被阻塞直到第一个事务完成。这种形式的锁在实际中应用的很好（特别是所有的关系型数据库都实现了它），但是可能会导致客户端等待获取锁而长时间等到锁。</p>
<p>由于这种可能存在的长时间等待，并且 Redis 的设计就是较少客户端的等待时间，Redis 在 <code>WATCH</code>期间并不会锁数据，相反，Redis 会通知客户端，如果其它客户端先修改了数据，这也被称之为乐观锁 (optimistic locking). 关系型数据库执行的锁可以被视作悲观锁 (pessimistic). 乐观锁同样也应用广泛，因为客户端从来不等待第一个锁的持有者释放锁，它只是在不断地进行重试。</p>

                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/3/">
            <i class="iconfont icon-prev"></i>
            Prev
        </a>
        
        
        <a class="next" href="/page/5/">
            Next
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/weirdwimp">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2023
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin"></a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>

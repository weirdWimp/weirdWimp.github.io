<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>The Cabin in the City</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                About
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">'s Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/%E9%AB%98%E7%BA%A7%E6%96%87%E6%9C%AC%E5%91%BD%E4%BB%A4/">高级文本命令</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2022-07-16</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h1 id="高级文本命令"><a href="#高级文本命令" class="headerlink" title="高级文本命令"></a>高级文本命令</h1><h3 id="1-sed-命令"><a href="#1-sed-命令" class="headerlink" title="1 sed  命令"></a>1 sed  命令</h3><h5 id="synopsis-基本用法"><a href="#synopsis-基本用法" class="headerlink" title="synopsis - 基本用法"></a><strong>synopsis - 基本用法</strong></h5><p>sed [OPTION]… {script-only-if-no-other-script} [input-file]..</p>
<h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://www.cnblogs.com/theCambrian/p/3606214.html" target="_blank" rel="noopener">博客园  sed 的工作原理</a></p>
<p><code>man sed</code></p>
<h5 id="option"><a href="#option" class="headerlink" title="option"></a><strong>option</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># suppress automatic printing of pattern space</span></span><br><span class="line"><span class="comment"># 关闭 pattern space 的自动打印，如果 command 中已经指定了 p, 可能就需要指定该选项</span></span><br><span class="line">-n, --quiet, --silent</span><br></pre></td></tr></table></figure>



<h5 id="script-command"><a href="#script-command" class="headerlink" title="script command"></a><strong>script command</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d      <span class="comment"># Delete pattern space.  Start next cycle.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy 即覆盖， append 即追加</span></span><br><span class="line">h H    <span class="comment"># Copy/append pattern space to hold space.</span></span><br><span class="line">g G    <span class="comment"># Copy/append hold space to pattern space.</span></span><br><span class="line">x      <span class="comment"># Exchange the contents of the hold and pattern spaces.</span></span><br><span class="line"></span><br><span class="line">n N    <span class="comment"># Read/append the next line of input into the pattern space.</span></span><br><span class="line">p      <span class="comment"># Print the current pattern space.</span></span><br><span class="line">P      <span class="comment"># Print up to the first embedded newline of the current pattern space.</span></span><br><span class="line"></span><br><span class="line">w filename <span class="comment"># Write the current pattern space to filename.</span></span><br><span class="line">W filename <span class="comment"># Write the first line of the current pattern space to filename.  This is a GNU extension.</span></span><br></pre></td></tr></table></figure>
<h5 id="examples"><a href="#examples" class="headerlink" title="examples"></a><strong>examples</strong></h5><ul>
<li>逆序打印文件行，等同于 <code>tac</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行，只将 pattern space 中的内容 copy 到 hold space，再删除 pattern space，下一轮循环</span></span><br><span class="line"><span class="comment"># 接下来，每一行，将 hold space 的内容 append 到 pattern space，再删除 pattern space，下一轮循环</span></span><br><span class="line">sed <span class="string">'1&#123;h;d&#125;;G;h;$!d'</span> seq.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed <span class="string">'1!G;h;$!d'</span> t.txt</span><br><span class="line"><span class="comment"># 1!G —— 只有第一行不执行G命令，将hold space中的内容append回到pattern space</span></span><br><span class="line"><span class="comment"># h —— 第一行都执行h命令，将pattern space中的内容拷贝到hold space中</span></span><br><span class="line"><span class="comment"># $!d —— 除了最后一行不执行d命令，其它行都执行d命令，删除当前行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定要处理的行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印第一行，1 指定第一行</span></span><br><span class="line">sed  -n <span class="string">'1p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印除了第一行的所有行</span></span><br><span class="line">sed -n <span class="string">'1!p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印奇数行，如第 1 行，第 3 行，第 5 行...， 语义为，从第一行开始，每隔 2 行打印</span></span><br><span class="line">sed -n <span class="string">'1~2p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印偶数行, 语义为每隔 2 行，打印</span></span><br><span class="line">sed -n <span class="string">'0~2p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第一行，以及后续连续的 5 行</span></span><br><span class="line">sed -n <span class="string">'1,+5p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印第一行，直到第一次遇到行号是 2 的倍数的行，打印</span></span><br><span class="line">sed -n <span class="string">'1,~2p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最后一行</span></span><br><span class="line">sed -n <span class="string">'$p'</span> seq.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line">sed -n <span class="string">'/regex/p'</span> seq.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp; 代表匹配的内容</span></span><br><span class="line"><span class="built_in">echo</span> &#123;a..z&#125; | xargs -n 1 | sed <span class="string">"s/[a-z]/[&amp;]/g"</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>sed表达式通常用单引号来引用。不过也可以使用双引号。 shell会在调用sed前先扩展双引<br>号中的内容。如果想在sed表达式中使用变量，双引号就能派上用场了。</p>
</blockquote>
<h4 id="2-cut"><a href="#2-cut" class="headerlink" title="2 cut"></a>2 cut</h4><p>synopsis - 基本用法</p>
<p>cut OPTION  [FILE]</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d, --delimiter		<span class="comment"># 指定列分隔符</span></span><br><span class="line">-f, --fields		<span class="comment"># 制定要打印的列（不包含列分隔符的行同样会被打印，除非指定 -s）</span></span><br><span class="line">--complement		<span class="comment"># 打印指定之外的列、字符或字节（相当于取反）</span></span><br><span class="line">-output-delimiter	<span class="comment"># 指定打印时的列分隔符</span></span><br><span class="line">-z 					<span class="comment"># 行分隔符为 NUL， cut 是对一行进行切割的</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cut -d <span class="string">","</span> f 2,5 file		<span class="comment"># 打印第2列，第5列</span></span><br><span class="line">cut -d <span class="string">","</span> f 2-5 file		<span class="comment"># 打印第2列到第5列</span></span><br><span class="line">cut -d <span class="string">","</span> f 2-5 --complement file	<span class="comment"># 打印除了2-5列的其他列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制定打印第几个字节、字符、列（区间）</span></span><br><span class="line"><span class="comment"># N-M 从第N个字节、字符或字段开始到行尾</span></span><br><span class="line"><span class="comment"># N-  从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</span></span><br><span class="line"><span class="comment"># -M  从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> &#123;a..z&#125; | cut -d <span class="string">" "</span> -f-4</span><br><span class="line"><span class="comment"># result: a b c d</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"4 3\x001 2"</span> | cut -z -d <span class="string">" "</span> --output-delimiter <span class="string">"#"</span> -f1,2</span><br></pre></td></tr></table></figure>





<h4 id="3-awk"><a href="#3-awk" class="headerlink" title="3 awk"></a>3 awk</h4><p>awk BEGIN{} PATTERN {} END{}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk 的 pattern</span></span><br><span class="line">$ awk <span class="string">'NR &lt; 5'</span> <span class="comment"># 行号小于5的行</span></span><br><span class="line">$ awk <span class="string">'NR==1,NR==4'</span> <span class="comment"># 行号在1到5之间的行</span></span><br><span class="line">$ awk <span class="string">'/linux/'</span> <span class="comment"># 包含模式为linux的行（可以用正则表达式来指定模式）</span></span><br><span class="line">$ awk <span class="string">'!/linux/'</span> <span class="comment"># 不包含模式为linux的行</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F":" 'BEGIN&#123;OFS="#"&#125; &#123;print $1,$2&#125;'</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># awk可以调用命令并读取输出。把命令放入引号中，然后利用管道将命令输出传入getline：</span></span><br><span class="line">awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123; "grep root /etc/passwd" | getline; \</span></span><br><span class="line"><span class="string">print $1,$6 &#125;'</span></span><br><span class="line"></span><br><span class="line">root /root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">'/import.+/ &#123; print "echo "$0"|grep -o com"|"bash" &#125;'</span> import</span><br></pre></td></tr></table></figure>



<h4 id="4-tr"><a href="#4-tr" class="headerlink" title="4 tr"></a>4 tr</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> alnum：字母和数字。</span><br><span class="line"> alpha：字母。</span><br><span class="line"> cntrl：控制（非打印）字符。</span><br><span class="line"> digit：数字。</span><br><span class="line"> graph：图形字符。</span><br><span class="line"> lower：小写字母。</span><br><span class="line"> <span class="built_in">print</span>：可打印字符。</span><br><span class="line"> punct：标点符号。</span><br><span class="line"> space：空白字符。</span><br><span class="line"> upper：大写字母。</span><br><span class="line"> xdigit：十六进制字符。</span><br></pre></td></tr></table></figure>




                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/Vim%20Editiong%20Basics/">Vim Editiong Basics</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2022-06-03</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h1 id="Editing-Basics"><a href="#Editing-Basics" class="headerlink" title="Editing Basics"></a>Editing Basics</h1><h3 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h3><p>当你编辑一个文件时， Vim 将磁盘上的文件内容读取到计算机的 RAM 中. 这意味这文件的一个备份被存储到了计算机的内存中，你对文件做出的任何修改，是直接映射到内存中的，并且会立即展示出来. 一旦完成了编辑，你可以保存文件，这意味着 Vim 将内存中的内容要写回磁盘. 临时存储文件的内存被称为缓存  (<strong>Buffer</strong>) .  所以，这就是为什么编辑完后要保存文件的原因.</p>
<h3 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h3><p>当你编辑文件时, 会在相同目录下会创建一个类似于 <code>.hello.txt.swp</code> 的文件. 查看确切的文件名可以使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:swapname</span><br></pre></td></tr></table></figure>

<p> Vim 维护了文件缓存区 (buffer) 的一个文件备份, 会定期保存到该文件中, 以避免出现问题时进行恢复 (如 计算机或者 Vim 程序崩溃).  这个文件被称为 <code>swap file</code>, 因为 Vim 会不断交换内存中的内容到磁盘上的文件中.</p>
<h3 id="Save-my-file"><a href="#Save-my-file" class="headerlink" title="Save my file"></a>Save my file</h3><p>当你修改了文件时, 并且没有保存, 在另一个窗口查看时, 此时是不会看到之前修改的内容的, 这也很好理解, 因为 Vim 只修改了 buffer 中的内容, 还没有保存到磁盘上. 可以通过  <code>:write</code> 命令来完成保存过程, 将内存中的内存写到磁盘中.</p>
<p><strong>为了让生活变得容易一点, 你可以使用快捷键映射, 在 vimrc 文件中:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#To save,ctrl-s.</span></span><br><span class="line">nmap &lt;c<span class="_">-s</span>&gt; :w&lt;CR&gt;</span><br><span class="line">imap &lt;c<span class="_">-s</span>&gt; &lt;Esc&gt;:w&lt;CR&gt;a</span><br></pre></td></tr></table></figure>



<h3 id="Cut-Copy-and-paste"><a href="#Cut-Copy-and-paste" class="headerlink" title="Cut, Copy and paste"></a>Cut, Copy and paste</h3><table>
<thead>
<tr>
<th>desktop</th>
<th>vim word</th>
<th>operation</th>
</tr>
</thead>
<tbody><tr>
<td>cut</td>
<td>delete</td>
<td>d</td>
</tr>
<tr>
<td>copy</td>
<td>yank</td>
<td>y</td>
</tr>
<tr>
<td>paste</td>
<td>put</td>
<td>p</td>
</tr>
</tbody></table>
<p>剪切操作在 Vim 中意味着从 buffer 中删除文本, 并将其存储到寄存器中</p>
<p>复制操作中同样也意味着拉取 (yank) 文本,并将其放到寄存器中</p>
<p>粘贴没有其特殊含义</p>
<p><strong>Why yank not copy ?</strong></p>
<blockquote>
<p><strong>Yanking is just a Vim name for copying.  The “c” letter was already used for the change operator, and “y” was still available.  Calling this operator “yank” made it easier to remember to use the “y” key.</strong></p>
<p>– Vim User Manual</p>
</blockquote>
<h4 id="如何在-Vim-中指定要在哪些文本上应用-cut-copy-paste-操作"><a href="#如何在-Vim-中指定要在哪些文本上应用-cut-copy-paste-操作" class="headerlink" title="如何在 Vim 中指定要在哪些文本上应用 cut/copy/paste 操作?"></a>如何在 Vim 中指定要在哪些文本上应用 cut/copy/paste 操作?</h4><p>你可以:</p>
<table>
<thead>
<tr>
<th>command</th>
<th>operation</th>
</tr>
</thead>
<tbody><tr>
<td>dl</td>
<td>删除单个字符</td>
</tr>
<tr>
<td>dw</td>
<td>删除一个单词</td>
</tr>
<tr>
<td>dd</td>
<td>删除一行</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标位置到行尾的所有字符</td>
</tr>
<tr>
<td>dwwP</td>
<td>交换两个单词</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p><strong>是不是很棒, 这里最让人激动的事情在于, 你可以结合之前的移动等命令, 更多的可能不是吗?  一般的编辑器, 可能没有办法做到如此简洁, 有力 , 并保持方便记忆 !</strong></p>
<p>还记得清空当前文档的操作吗 ?</p>
<h3 id="words"><a href="#words" class="headerlink" title="words"></a>words</h3><ul>
<li><code>w</code></li>
<li><code>e</code></li>
</ul>
<h3 id="Sentence"><a href="#Sentence" class="headerlink" title="Sentence"></a>Sentence</h3><ul>
<li><code>(</code></li>
<li><code>)</code></li>
</ul>
<h3 id="Paragraph"><a href="#Paragraph" class="headerlink" title="Paragraph"></a>Paragraph</h3><ul>
<li><code>{</code></li>
<li><code>}</code></li>
</ul>
<h3 id="Visual-Mode-Select"><a href="#Visual-Mode-Select" class="headerlink" title="Visual Mode Select"></a>Visual Mode Select</h3><ul>
<li><p><code>aw</code></p>
<p> select a word</p>
</li>
<li><p><code>ap</code></p>
<p>select a paragraph</p>
</li>
<li><p><code>ab</code></p>
<p>select a block (anything with a pair of parentheses)</p>
</li>
<li><p><code>a&quot;</code></p>
<p>select a quoted string (like “this is a quoted string”)</p>
</li>
</ul>
<h3 id="Marking-your-territory"><a href="#Marking-your-territory" class="headerlink" title="Marking your territory"></a>Marking your territory</h3><ul>
<li><p>create a mark where you can jump here later</p>
<p><code>ma</code> (a-zA-Z ) then you create a mark called ‘a’</p>
</li>
<li><p>return the cursor to the mark</p>
<p><code>&#39;a</code> take you to the exact line and column of the mark</p>
</li>
</ul>
<h3 id="Time-machine-using-undo-redo"><a href="#Time-machine-using-undo-redo" class="headerlink" title="Time machine using undo/redo"></a>Time machine using undo/redo</h3><ul>
<li><p><code>u</code> undo  :leftwards_arrow_with_hook:</p>
</li>
<li><p><code>ctrl-r</code> redo :arrow_right_hook:</p>
</li>
<li><p>more…</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># take you back by 4 minutes</span></span><br><span class="line">:earlier 4m</span><br><span class="line"></span><br><span class="line"><span class="comment"># take you later by 45 seconds</span></span><br><span class="line">:later 45s</span><br><span class="line"></span><br><span class="line"><span class="comment"># go back 5 changes</span></span><br><span class="line">undo 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># view the undo tree</span></span><br><span class="line">undolist</span><br></pre></td></tr></table></figure>



<h3 id="Powerful-search-engine"><a href="#Powerful-search-engine" class="headerlink" title="Powerful search engine"></a>Powerful search engine</h3><ul>
<li>basic search*</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search</span></span><br><span class="line">/the&lt;cr&gt; <span class="comment"># /the followed by the enter key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># next occurrence</span></span><br><span class="line">press `n`</span><br><span class="line"></span><br><span class="line"><span class="comment"># previous occurrence</span></span><br><span class="line">press `N`</span><br></pre></td></tr></table></figure>

<p>  还记得我们第一次介绍 Vim 的骚操作吗 <code>*</code> 搜索当前光标所在的单词</p>
<ul>
<li>start searching as and when you type the search phrase</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> incsearch</span><br></pre></td></tr></table></figure>

<ul>
<li>ignore the case of the text that you are searching for</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ignorecase</span><br></pre></td></tr></table></figure>

<ul>
<li>smart case</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> smartcase</span><br></pre></td></tr></table></figure>

<ul>
<li>searching for <code>/step</code>, then it will search for any combination of upper and lower case text. So eventually, “Step”, “Stephen”,”stepbrother”</li>
<li>searching for <code>/Step</code>, <strong>only</strong> “Step”, “Stephen”, but not “stepbrother”</li>
</ul>
<ul>
<li>basic patterns</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exactly search the word 'step' and not 'stepfather'</span></span><br><span class="line">/\&lt;step\&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># search numbers</span></span><br><span class="line">/\d\+</span><br><span class="line"></span><br><span class="line"><span class="comment"># see :help pattern for more details</span></span><br></pre></td></tr></table></figure>



<p><strong>永远不要去死记硬背这些操作, 试着理解, 并练习, 最终成为肌肉记忆.</strong></p>
<p><a href="http://vimdoc.sourceforge.net/htmldoc/usr_04.html" target="_blank" rel="noopener">vim doc</a></p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/Vim%20Powerful%20Commands/">Vim Powerful Commands</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2022-05-29</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Vim-Versatile-commands"><a href="#Vim-Versatile-commands" class="headerlink" title="` Vim Versatile commands"></a>` Vim Versatile commands</h2><ul>
<li><p><code>.</code></p>
<ul>
<li><p>通过 Normal Mode （命令行模式）下的 <code>.</code> 命令来重复上一次的修改操作. 上一次的修改意味着很多操作：Normal Mode 下删除一个或多个字符，单词，行， 如 <code>x</code>, <code>dw</code>, <code>d$</code>, <code>dd</code> 等；比如改变缩进的命令：<code>&gt;&gt;</code>, <code>&lt;&lt;</code> 等. </p>
</li>
<li><p>命令行模式下大多数命令对文本做出的修改，都可以使用 <code>.</code> 来重复；Insert Mode （编辑模式） 下做出的修改的重复取决于进入该模式的命令，加入，你通过 <code>A</code> 进入 Insert Mode, 在末尾添加了单词 <code>end</code>，按下 <code>Esc</code>,  <code>.</code> 命令会在末尾重复添加单词 <code>end</code>.</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. You are now in Normal Mode, you have the text like those below:</span></span><br><span class="line"></span><br><span class="line">This is </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Press A to enter Insert Mode and write text `end`</span></span><br><span class="line">This is end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Press Esc to enter Normal Mode and press .(period), things will happen like this:</span></span><br><span class="line">This is end end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. mode dot, mode ` end`</span></span><br><span class="line">This is end end end</span><br></pre></td></tr></table></figure>

<ul>
<li><code>5.</code> 表示重复执行多少次</li>
<li>Motions (光标的移动) 并不会改变任何事情，所以 <code>.</code> 并不会进行重复</li>
</ul>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Redis/Redis%20Cluster/">Redis Cluster</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-12-04</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Redis/">Redis</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>consistent hashing 一致性哈希</p>
<p>hash slot 哈希槽</p>
<h2 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h2><p>Redis 集群没有使用一致性哈希，而是使用了一种不同的数据分片形式: 每个键在概念上属于所谓的 <strong>哈希槽</strong> (hash slot) 的一部分。Redis 集群一共有 16384 个哈希槽，计算一个给定键的哈希槽，采取的方式是：<strong>键的 CRC16 对 16384 取模</strong>。</p>
<p>Redis 集群中的每一个节点都负责所有哈希槽的一个子集. 假如一个集群有三个节点，那么哈希槽的分布可能是这样:</p>
<ul>
<li>A 节点的哈希槽范围 0 - 5500</li>
<li>B 节点的哈希槽范围 5501 - 11000</li>
<li>C 节点的哈希槽范围 11001 - 16383</li>
</ul>
<p>这使得很容易在集群中增加和移除节点。例如，如果想增加一个新节点 D, 需要将 A,B,C 中的某些哈希槽移动到 D. 类似的，如果想要移除节点 A, 可以将 A  负责的哈希槽移动到 B 和 C。</p>
<p>由于从一个节点向另一个节点移动哈希槽并不需要停止操作，增加和移除节点或者改变节点所负责的哈希槽的百分比，不需要任何的宕机操作。</p>
<p>Redis 集群支持多个键的操作（多个键的同时操作），只要单个命令的执行（Redis事务，Lua脚本执行）所涉及的这些键，都属于同一个哈希槽。用户可以通过使用一个叫做 <strong>哈希标签</strong>  (hash tags) 的概念，强制多个键属于不同的哈希槽.</p>
<p>Redis 集群规范中记录了哈希标签，但重点是，如果键中的 <code>{}</code> 括号之间有一个子字符串，则仅对字符串内的内容进行哈希处理，例如 <code>this{foo}key</code> 和 <code>another{foo} key</code> 保证在同一个哈希槽中，并且可以在一个命令中一起使用多个键作为参数。</p>
<h2 id="Redis-集群的主复制模式"><a href="#Redis-集群的主复制模式" class="headerlink" title="Redis 集群的主复制模式"></a>Redis 集群的主复制模式</h2><p>Redis Cluster master-replica model</p>
<p>为了保证可以用性, 当主节点中的某些节点出现故障或者不能与集群中的大多数节点进行通信时, Redis 集群使用了一种主节点复制模式, 即每个哈希槽都有一个到 N 个副本 (N-1 个额外的副本节点).</p>
<p>在上述 A, B, C 三个节点的集群中, 如果节点 B 故障, 集群不能与之通信, 那么就不再能够提供哈希槽 0-5500 范围的服务. 然而, 如果在创建集群的时候, 为每一个主节点增加一个副本节点, 那么最终集群包含了 A, B, C 以及对应的副本节点 A1, B1, C1. 这样, 系统就能够在 B 节点故障时继续提供服务.</p>
<p>B1 节点复制节点 B, 如果 B 节点故障, 集群将使得 B1 成为新的主节点继续正确地提供服务. 但是如果 B1 和 B 同一时间都故障了, 那么集群就不能继续服务.</p>
<h2 id="Redis-集群地一致性保障"><a href="#Redis-集群地一致性保障" class="headerlink" title="Redis 集群地一致性保障"></a>Redis 集群地一致性保障</h2><p>Redis Cluster consistency guarantees</p>
<p>Redis Cluster 无法保证强一致性。实际上，这意味着在某些条件下，Redis Cluster 可能会丢失系统已向客户端确认的写入。</p>
<p>Redis Cluster 会丢失写入的第一个原因是因为它使用异步复制。这意味着在写入期间会发生以下情况：</p>
<p>客户端写入主 B。<br>主 B 向客户端回复 OK。<br>主 B 将写入传播到其副本 B1、B2 和 B3。</p>
<p>B 在回复客户端之前不会等待来自 B1、B2、B3 的确认，因为这对 Redis 来说是一个令人望而却步的延迟惩罚，因此如果您的客户端写入某些内容，B 会确认写入，但会在此之前崩溃能够将写入发送到其副本，其中一个副本（未收到写入）可以提升为主，永远失去写入。</p>
<p>这与大多数配置为每秒将数据刷新到磁盘的数据库发生的情况非常相似，因此您已经能够推理出这种情况，因为过去使用不涉及分布式系统的传统数据库系统的经验。同样，您可以通过强制数据库在回复客户端之前将数据刷新到磁盘来提高一致性，但这通常会导致性能低得令人望而却步。在 Redis Cluster 的情况下，这相当于同步复制。</p>
<p>基本上，需要在性能和一致性之间进行权衡。</p>
<p>Redis 集群在绝对需要时支持同步写入，通过 WAIT 命令实现。这使得丢失写入的可能性大大降低。但是请注意，即使使用同步复制，Redis Cluster 也没有实现强一致性：在更复杂的故障场景下，始终有可能将无法接收写入的副本选为 master。</p>
<p>还有一个值得注意的场景是 Redis 集群将丢失写入，这发生在网络分区期间，客户端与少数实例（至少包括一个主实例）隔离。</p>
<p>以我们的 6 个节点集群为例，它由 A、B、C、A1、B1、C1 组成，有 3 个主节点和 3 个副本节点。还有一个客户端，我们将其称为 Z1。</p>
<p>分区发生后，可能在分区的一侧有 A、C、A1、B1、C1，而在另一侧有 B 和 Z1。</p>
<p>Z1 仍然能够写入 B，B 将接受其写入。如果分区在很短的时间内愈合，集群将继续正常运行。但是，如果分区持续足够的时间让 B1 在分区的多数侧提升为 master，则 Z1 同时发送给 B 的写入将丢失。</p>
<p>请注意，Z1 能够发送到 B 的写入量有一个最大窗口：如果分区的多数方已经有足够的时间来选举一个副本作为主节点，那么少数方的每个主节点都将停止接受写入。</p>
<p>这个时间量是Redis Cluster一个非常重要的配置指令，称为节点超时。</p>
<p>节点超时后，主节点被视为出现故障，并且可以由其副本之一替换。类似地，在节点超时过后，主节点无法感知大多数其他主节点，它会进入错误状态并停止接受写入。</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Redis/Redis%20%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/">Redis 的持久化</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-11-21</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Redis/">Redis</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h1 id="Redis-数据持久化"><a href="#Redis-数据持久化" class="headerlink" title="Redis 数据持久化"></a>Redis 数据持久化</h1><p>Redis 中，有两种方式将数据持久化到磁盘。一种称之为<strong>快照</strong> (Spapshotting), 将某一时刻存在数据写道磁盘。另外一种称之为<strong>AOF 仅追加文件</strong> (append-only file), 它是将到来的所有写命令写到磁盘上。这两种方式可以一起使用，也可以单独使用，或者不适用持久化。</p>
<p>选择配置数据持久话的原因还是为了在 Redis，Redis 所在的主机硬件等发生故障时进行恢复，可以将持久化的文件在远程主机进行备份，故障时进行恢复。而且，如果 Redis 中的数据时大数据集上的聚合分析结果，没有备份，重新计算的代价可能时无法接受的。</p>
<h2 id="通过快照将数据持久化到磁盘"><a href="#通过快照将数据持久化到磁盘" class="headerlink" title="通过快照将数据持久化到磁盘"></a>通过快照将数据持久化到磁盘</h2><p>在 Redis 中，可以通过创建一个快照，创建一个内部中数据的某个时刻的副本，这些副本可以被备份，复制到其它服务器，创建一个 Redis 服务器的副本，或者留着待以后重启使用。</p>
<h3 id="基本的配置选项"><a href="#基本的配置选项" class="headerlink" title="基本的配置选项"></a><strong>基本的配置选项</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000 <span class="comment"># 创建快照的频率。如果自上一次创建快照后的 60s 内有 1000 此写，就开启新的快照</span></span><br><span class="line">stop-writes-on-bgsave-error no <span class="comment"># 当创建快照时，发生异常是否暂停所有的写命令</span></span><br><span class="line">rdbcompression yes   <span class="comment"># 是否进行压缩</span></span><br><span class="line">dbfilename dump.rdb  <span class="comment"># 快照文件名</span></span><br><span class="line"></span><br><span class="line">dir ./ <span class="comment"># 快照文件保存的目录</span></span><br></pre></td></tr></table></figure>

<p>自上一次快照完成后，直到下一次快照开始执行，这个期间，如果 Redis 崩溃，系统或硬件故障，期间的写数据就会丢失。</p>
<h3 id="五种初始化快照的方法"><a href="#五种初始化快照的方法" class="headerlink" title="五种初始化快照的方法"></a>五种初始化快照的方法</h3><ol>
<li><p>任何的 Redis 客户端都可以通过调用 <code>BGSAVE</code> 命令来初始化快照（创建快照）。在所有支持 <code>BGSAVE</code>  的平台上，Redis 会进行进程的 <strong><em>fork</em></strong>, 子进程会将快照写到磁盘，而父进程仍然可以用于响应来自客户端的命令。</p>
<blockquote>
<p>当一个进程 fork 时，底层的操作系统会创建该进程的一个副本。在 Unix 和类 Unix 的系统上，复制进程会被优化：最开始，子进程和父进程时共享所有内存的。当父进程或子进程开始写内存，内存将不再共享。</p>
</blockquote>
</li>
<li><p>Redis 的客户端可以通过调用 <code>SAVE</code> 命令来初始化快照，这将导致 <strong>Redis 停止对任何命令的响应</strong>，直到快照完成。不经常使用，但是如果对于该这种等待 ok 或者没有足够的内存执行 <code>BGSAVE</code> 操作，可以使用。</p>
</li>
<li><p>如果 Redis 配置了 <code>save</code> 选项，如 <code>save 60 10000</code>， 如果自上一次快照成功后的 60s 内，已经有 10000 个写操作，那么 Redis 会自动触发一个 <code>BGSAVE</code> 操作。可以配置多个 <code>save</code> 行，任意一条规则满足，就会触发 <code>BGSAVE</code> 操作。</p>
</li>
<li><p>当 Redis 接受到 <code>SHUTDOWN</code> 终止命令时，或者接受到标准的 <code>TERM</code> 信号，Redis 会执行 <code>SAVE</code> 操作，阻塞任何客户端执行任何命令，然后再终止。</p>
</li>
<li><p>当一个 Redis 服务器连接到另一个 Reids 服务器，并且发起了 <code>SYNC</code> 同步命令开始复制（replication）, Master Redis 服务器将会开始一个 <code>BGSAVE</code> 操作，如果当前没有一个正在进行中的 <code>BGSAVE</code> 操作或者最近完成了。</p>
</li>
</ol>
<h2 id="只追加写文件持久化-Append-only-file-persistence"><a href="#只追加写文件持久化-Append-only-file-persistence" class="headerlink" title="只追加写文件持久化 (Append-only file persistence)"></a>只追加写文件持久化 (Append-only file persistence)</h2><p>只追加写文件通过将修改写到文件的末尾，保存了数据发生修改时的记录。这样，任何人都有可以通过从头到尾，重放 (replay) 只追加写日志文件就可以恢复整个数据集。可以通过设置配置项 <code>appendonly yes</code> 开启。</p>
<h3 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h3><p>当写文件到磁盘上时，至少发生了三件事：首先是写缓存，当调用 <code>file.write()</code> 或其它语言中等价的命令时会执行该操作。当数据存在缓冲区中时，操作系统可以将这些数据再未来的某个时刻写到磁盘。可以通过调用 <code>file.flush()</code>, 要求操作系统将数据写到磁盘上，但这只是发给操作系统的一个请求，并不会立即执行。由于数据实际时不在磁盘上的直到操作系统将它写到磁盘上，我们可以告诉操作系统<strong>同步</strong>文件到磁盘上，这将导致阻塞 (block)，直到同步完成。当同步完成时，我们可以确定数据此时是在磁盘上的，并且如果系统故障，可以稍后读取进行恢复。</p>
<h4 id="appendfsync-always"><a href="#appendfsync-always" class="headerlink" title="appendfsync always"></a><code>appendfsync always</code></h4><p>如果设置了 <code>appendfsync always</code>, Redis 的每次写将会导致一个磁盘的写过程，如果 Reid 崩溃了，这可以极大地减少数据丢失。然而，因为每次都有写磁盘这个过程，整体的性能会受限于此磁盘的性能。</p>
<h4 id="appendfsync-eversec"><a href="#appendfsync-eversec" class="headerlink" title="appendfsync eversec"></a><code>appendfsync eversec</code></h4><p>作为保持数据安全和保持高写入性能之间的合理折衷，我们还可以设置 appendfsync everysec。 此配置将每秒同步一次仅追加日志文件。 对于大多数常见用途，与不使用任何类型的持久性相比，我们可能不会发现每秒同步到磁盘的显着性能损失。 通过每秒同步到磁盘，如果系统崩溃，我们最多可能会丢失一秒钟已在 Redis 中写入或更新的数据。 此外，在磁盘无法跟上正在发生的写入量的情况下，Redis 会优雅地减速以适应驱动器的最大写入速率。</p>
<h4 id="appendfsync-no"><a href="#appendfsync-no" class="headerlink" title="appendfsync no"></a><code>appendfsync no</code></h4><p>Redis 并不会显示地执行任何文件同步，而是将这一切交给操作系统。这种情况下应该没有性能损失，但如果系统以某种方式崩溃，我们将丢失未知和不可预测的数据量。 如果我们使用的硬盘驱动器对于我们的写入负载来说不够快，Redis 会运行良好，直到将数据写入磁盘的缓冲区被填满，此时 Redis 会因为被阻止写入而变得非常慢。 通常不鼓励使用此配置选项。</p>
<h3 id="重写-压缩-AOF"><a href="#重写-压缩-AOF" class="headerlink" title="重写/压缩 AOF"></a>重写/压缩 AOF</h3><p>AOF 看起来比较完美，即能将数据损失降低到 1s，又可以最小化数据持久化到磁盘上地时间。但是问题是，Redis 的每次写命令，都会生成一条日志记录，随着时间的推移，AOF 日志文件的大小会不断增长，可能会导致磁盘空间耗尽。但更常见的问题是，在 Redis 重启时，由于需要按顺序执行 AOF 中的每条命令，处理较大的文件，需要花费更长的时间</p>
<p>此时可以使用 <code>BGREWRITEAOF</code>, 它会通过移除冗余的命令，来尽可能地使得 AOF 变得更小一点。和 <code>BGSAVE</code> 命令一样，这个命令也会执行一次 fork 过程，由子进程完成 AOF 的重写，所以关于 fork 的时间，内存使用的问题，同样也适用于 <code>BGREWRITEAOF</code>。而且更糟的时，当 AOF 被重写，操作系统需要删除几十 G 的 AOF 文件时，会使的操作系统中断几秒。</p>
<p>当启用 AOF , 并且满足以下两个配置项时，Redis 会启动一次 <code>BGREWRITEAOF</code>， 如果 AOF 重写的频率过高，可以适当增加 <code>auto-aof-rewritepercentage</code>， 但是可能会导致 Redis 启动需要花费更多的时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当 AOF 至少比 Redis 上次完成重写时的 AOF 大 100% 时</span></span><br><span class="line">auto-aof-rewritepercentage 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 AOF 的大小至少为 64m 字节时</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>



<h2 id="复制-Replication"><a href="#复制-Replication" class="headerlink" title="复制 Replication"></a>复制 Replication</h2>
                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/3/">
            <i class="iconfont icon-prev"></i>
            Prev
        </a>
        
        
        <a class="next" href="/page/5/">
            Next
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/weirdwimp">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2024
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin"></a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>The Cabin in the City</title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/" class="header-nav-link" >
                Home
            </a>
            

            
            <a href="/archives" class="header-nav-link">
                Archives
            </a>
            

            
            <a href="/tags" class="header-nav-link">
                Tags
            </a>
            

            
            <a href="/about/" class="header-nav-link">
                About
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/" class="mobile-nav-title-link">'s Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/" class="mobile-nav-link">Home</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/archives" class="mobile-nav-link">Archives</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/tags" class="mobile-nav-link">Tags</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/about/" class="mobile-nav-link">About</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E4%B8%8E%E7%AB%AF%E5%8F%A3/">查看网络流量与端口</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-08-15</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>Linux 下常用的命令 <code>lsof</code> 和 <code>netstat</code> 都可以用来列出端口以及运行在端口上的服务。</p>
<h2 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h2><p> 为了验证这两个命令，在本地的一台 Ununtun 机器上部署了一个简单的 Kafka broker，端口为 9092，局域网 ip 为 192.168.31.188。在我的开发环境中，ip 为 192.168.31.51 启动了一个 kafka 生产者，在每一次生产消息后会进行休眠一段时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pid:"</span> + getPid());</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = createProducer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String time = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);</span><br><span class="line">            String message = <span class="string">"message at "</span> + time;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"message: "</span> + message);</span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"test"</span>, message);</span><br><span class="line">            producer.send(record, (r, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"topic:%s, partition:%s, offset:%s\n"</span>, r.topic(), r.partition(), r.offset());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            threadSleep(Duration.ofMinutes(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        producer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> KafkaProducer&lt;String, String&gt; <span class="title">createProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.31.188:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadSleep</span><span class="params">(Duration duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> millis = duration.toMillis();</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();</span><br><span class="line">        String name = runtime.getName(); <span class="comment">// format: "pid@hostname"</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(name.substring(<span class="number">0</span>, name.indexOf(<span class="string">'@'</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时打印出了该程序的进程 PID: pid:23264, 此过程也可以通过 Windos 下的任务管理器查看，如果是 IDEA 中运行的，可以在 <code>进程</code> 的选项卡下的 IntelliJ IDEA 子进程下查看</p>
<p><img src="https://raw.githubusercontent.com/weirdWimp/blog-store/main/img/image-20210815120804600.png" alt="image-20210815120804600"></p>
<p>Windos 下也有 <code>netstat</code> 命令来查看端口占用和相关的进程，我们找到进程 ID 为 23264 的所有连接，可以看到目标列，即为 Kafka 的 broker 监听的地址 （192.168.31.188:9092）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a 显示所有连接和侦听端口 -n 以数字形式显示地址和端口号 -o 显示拥有的与每个连接关联的进程 ID</span></span><br><span class="line">C:\Users\guo&gt;netstat <span class="literal">-ano</span> | findstr <span class="string">"23264"</span></span><br><span class="line">  协议    本地地址                外部地址                状态             PID</span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50281</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50280</span>        ESTABLISHED     <span class="number">23264</span></span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50282</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50283</span>        ESTABLISHED     <span class="number">23264</span></span><br><span class="line">  TCP    <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50283</span>        <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">50282</span>        ESTABLISHED     <span class="number">23264</span></span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">31.51</span>:<span class="number">50286</span>    <span class="number">192.168</span>.<span class="number">31.188</span>:<span class="number">9092</span>    ESTABLISHED     <span class="number">23264</span></span><br><span class="line">  TCP    <span class="number">192.168</span>.<span class="number">31.51</span>:<span class="number">50288</span>    <span class="number">192.168</span>.<span class="number">31.188</span>:<span class="number">9092</span>    ESTABLISHED     <span class="number">23264</span></span><br></pre></td></tr></table></figure>



<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>Linux 下的 <code>lsof</code>, 即 list open files, 列出已打开的文件， <code>-i</code> 选项列出打开的网络接口文件 ( -i select IPv[46] files)。在 kafka broker 所在机器下查看 9092 端口的使用情况，可以找到与之对应的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -n 以数字形式显示地址</span></span><br><span class="line">ph@guo-lenovo:~$ sudo lsof -i -n | grep 9092</span><br><span class="line">COMMAND      PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java      174961            root   95u  IPv6 2748921      0t0  TCP *:9092 (LISTEN)</span><br><span class="line">java      174961            root  100u  IPv6 2854156      0t0  TCP 192.168.31.188:9092-&gt;192.168.31.51:50286 (ESTABLISHED)</span><br><span class="line">java      174961            root  101u  IPv6 2854157      0t0  TCP 192.168.31.188:9092-&gt;192.168.31.51:50288 (ESTABLISHED)</span><br></pre></td></tr></table></figure>

<p><code>192.168.31.188:9092-&gt;192.168.31.51:50286</code> 箭头前表示本地地址（Source/Local），箭头后表示外部地址（Target/Foreign）</p>
<h3 id="打印所有开放的端口"><a href="#打印所有开放的端口" class="headerlink" title="打印所有开放的端口"></a>打印所有开放的端口</h3><p>根据输出的形式，可以以一个简单的脚本实现打印出当前所有的开放端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i | grep -Eo <span class="string">":[0-9a-zA-Z]+-&gt;"</span> | grep -Eo <span class="string">"[0-9a-zA-Z]+"</span> | sort | uniq</span><br></pre></td></tr></table></figure>



<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>Linux 下的 <code>netstat</code> 与 Windos 下的命令效果一样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t tcp</span></span><br><span class="line"><span class="comment"># -n, --numeric  don't resolve names</span></span><br><span class="line"><span class="comment"># -p, --programs display PID/Program name for sockets</span></span><br><span class="line">ph@guo-lenovo:~$ netstat -tnp | grep 9092</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 192.168.31.188:9092     192.168.31.51:50288     ESTABLISHED -</span><br><span class="line">tcp6       0      0 192.168.31.188:9092     192.168.31.51:50286     ESTABLISHED -</span><br></pre></td></tr></table></figure>


                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Linux/%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E4%B8%8ESSH/">配置网络与SSH</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-08-14</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Linux/">Linux</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <p>[TOC]</p>
<h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>vmware 桥接模式下：</p>
<p>各种网络模式参考 <a href="https://www.linuxidc.com/Linux/2016-09/135521.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-09/135521.htm</a></p>
<p>/etc/sysconfig/network-scripts 下一般会有一个网络配置文件，如：ifcfg-eno16777736</p>
<p>修改该文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet          </span><br><span class="line">BOOTPROTO=static          <span class="comment">#静态IP地址配置</span></span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=eno16777736</span><br><span class="line">UUID=7617ff93-0c8f-4272-a28e-ac8cf0807026</span><br><span class="line">DEVICE=eno16777736</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.2.110        <span class="comment">#虚拟机的话，与主机同一网段</span></span><br><span class="line">NETMASK=255.255.255.0       <span class="comment">#子网掩码</span></span><br><span class="line">GATEWAY=192.168.2.1         <span class="comment">#网关</span></span><br><span class="line">DNS1=192.168.2.1            <span class="comment">#DNS</span></span><br></pre></td></tr></table></figure>

<p>修改完重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>









<h4 id="CentOS中修改主机名"><a href="#CentOS中修改主机名" class="headerlink" title="CentOS中修改主机名"></a>CentOS中修改主机名</h4><h5 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@centos6 ~]$ hostname                                              <span class="comment"># 查看当前的hostnmae</span></span><br><span class="line">centos6.magedu.com</span><br><span class="line">[root@centos6 ~]$ vim /etc/sysconfig/network                            <span class="comment"># 编辑network文件修改hostname行（重启生效）</span></span><br><span class="line">[root@centos6 ~]$ cat /etc/sysconfig/network                            <span class="comment"># 检查修改</span></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=centos66.magedu.com</span><br><span class="line">[root@centos6 ~]$ hostname centos66.magedu.com                          <span class="comment"># 设置当前的hostname(立即生效）</span></span><br><span class="line">[root@centos6 ~]$ vim /etc/hosts                                        <span class="comment"># 编辑hosts文件，给127.0.0.1添加hostname</span></span><br><span class="line">[root@centos6 ~]$ cat /etc/hosts                                        <span class="comment"># 检查</span></span><br><span class="line">127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 centos66.magedu.com</span><br><span class="line">::1 localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure>

<p>centos6以及其他有些发行版本，主机名的配置文件是<code>/etc/sysconfig/network</code>, 用 <code>hostname newname</code> 也只是暂时生效，修改了内核的值，重启丢失。 所以可以结合临时加修改配置文件这种方式修改主机名。</p>
<h5 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]$ hostnamectl <span class="built_in">set</span>-hostname centos77.magedu.com       <span class="comment"># 使用这个命令会立即生效且重启也生效</span></span><br><span class="line"></span><br><span class="line">[root@centos7 ~]$ hostname  <span class="comment"># 查看下</span></span><br><span class="line">centos77.magedu.com</span><br><span class="line"></span><br><span class="line">[root@centos7 ~]$ vim /etc/hosts   <span class="comment"># 编辑下hosts文件， 给127.0.0.1添加hostname</span></span><br><span class="line">[root@centos7 ~]$ cat /etc/hosts                                           <span class="comment"># 检查</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 centos77.magedu.com</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure>

<p>在centos7中，主机名的配置文件为 /etc/hostname, 在该文件中配置了新的主机名后，不会立即生效，需要重启进行生效；因为系统内核已经中的主机名还没有更新，还是旧的指。 可以使用修改CentOS6的策略，也可以通过 <code>hostnamectl set-hostname newname</code> 来更改主机名，内核和配置文件中的主机名都被更新了，不用重启。</p>
<p>至于<code>/etc/hosts</code> 文件，同Windows下的hosts文件一样，只是起到本地DNS的作用一样，路由的作用。或者也可以说起别名。</p>
<h4 id="SSH-服务配置"><a href="#SSH-服务配置" class="headerlink" title="SSH 服务配置"></a>SSH 服务配置</h4><p>首先查看是否有安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep openssh-server</span><br></pre></td></tr></table></figure>

<p>没有安装的话，用yum进行安装 <code>yum install openssh-server</code></p>
<p>SSH 服务的配置文件是 /etc/ssh/sshd_config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line">ListenAddress ::</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>

<p>重启或开启SSH服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd.service   <span class="comment">#自启动服务</span></span><br></pre></td></tr></table></figure>



<p>查看22端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum instatll net-tools –y    <span class="comment">#如果没有netstat服务，安装netstat工具</span></span><br><span class="line"></span><br><span class="line">netstat -an | grep 22</span><br></pre></td></tr></table></figure>



<p>必要时关闭防火墙或开放22端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>ssh-keygen -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key </p>
<h4 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h4><p><a href="https://www.cnblogs.com/zengkefu/p/5666947.html" target="_blank" rel="noopener">https://www.cnblogs.com/zengkefu/p/5666947.html</a></p>
<p>ntpdate cn.pool.ntp.org</p>
<p>\1.  安装ntpdate工具</p>
<p> # yum -y install ntp ntpdate</p>
<p> \2.  设置系统时间与网络时间同步</p>
<p> # ntpdate cn.pool.ntp.org</p>
<p> \3.  将系统时间写入硬件时间</p>
<p> # hwclock –systohc</p>
<p> 4.强制系统时间写入CMOS中防止重启失效</p>
<p> 　　hwclock -w<br> 　　或clock -w</p>
<p>本文来自 紫漪 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/u011391839/article/details/62892020?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/u011391839/article/details/62892020?utm_source=copy</a> </p>
<p>sudo passwd root 更改密码，要在root用户下</p>
<p>sudo su - root</p>
<p>apt list –installed|grep jdk java</p>
<p>/opt/zookeeper-3.4.6/bin/zkServer.sh start</p>
<p>/opt/kafka_2.11-0.9.0.1/bin/kafka-server-start.sh -daemon /opt/kafka_2.11-0.9.0.1/config/server.properties</p>
<p>/opt/kafka_2.11-0.9.0.1/bin/kafka-server-stop.sh </p>
<p>bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kafka-console-consumer.sh --zookeeper localhost:2181 --topic test1 --from-beginning</span><br></pre></td></tr></table></figure>
                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Spring/Spring%20Aysnc%20Request/">Spring Aysnc Request</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-08-07</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Spring/">Spring</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="Compare-to-WebFlux"><a href="#Compare-to-WebFlux" class="headerlink" title="Compare to WebFlux"></a>Compare to WebFlux</h2><p>Servlet API 最初是为通过 Filter-Servlet 链进行单次传递而构建的。 Servlet 3.0 中添加的异步请求处理允许应用程序退出 Filter-Servlet 链，但将响应保持打开状态以供进一步处理。 Spring MVC 异步支持是围绕该机制构建的。当控制器返回 DeferredResult 时，Filter-Servlet 链退出，Servlet 容器线程被释放。稍后，当设置了 DeferredResult 时，会进行 ASYNC 分派 (dispatch)（到相同的 URL），在此期间再次映射控制器，但不是调用它，而是使用 DeferredResult 值（就像控制器返回它一样）来恢复处理.</p>
<p>相比之下，Spring WebFlux 既不是建立在 Servlet API 上，也不需要这样的异步请求处理特性，因为它是异步设计的。异步处理内置于所有框架契约中，并且在请求处理的所有阶段都得到内在的支持。</p>
<p>从编程模型的角度来看，Spring MVC 和 Spring WebFlux 都支持异步和响应式类型作为控制器方法中的返回值。 Spring MVC 甚至支持流，包括反应式背压。但是，对响应的单个写入仍然是阻塞的（并且在单独的线程上执行），这与 WebFlux 不同，后者依赖于非阻塞 I/O，并且每次写入不需要额外的线程。</p>
<p>另一个根本区别是 Spring MVC 不支持控制器方法参数中的异步或反应类型（例如，@RequestBody、@RequestPart 等），也没有明确支持异步和反应类型作为模型属性。 Spring WebFlux 确实支持所有这些。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>出于安全原因，浏览器禁止对当前来源之外的资源进行 AJAX 调用。 例如，您可以在一个选项卡中拥有您的银行帐户，而在另一个选项卡中拥有 evil.com。 来自 evil.com 的脚本不应该能够使用您的凭据向您的银行 API 发出 AJAX 请求 — 例如从您的帐户中取款！</p>
<p>跨域资源共享 (CORS) 是大多数浏览器实现的 W3C 规范，它允许您指定授权的跨域请求类型，而不是使用基于 IFRAME 或 JSONP 的安全性较低且功能较弱的解决方法。</p>
<p>CORS 规范区分了预检请求、简单请求和实际请求。要了解 CORS 的工作原理，您可以阅读本文等，或查看规范以获取更多详细信息。</p>
<p>Spring MVC HandlerMapping 实现为 CORS 提供了内置支持。成功将请求映射到处理程序后，HandlerMapping 实现会检查给定请求和处理程序的 CORS 配置并采取进一步行动。预检请求被直接处理，而简单和实际的 CORS 请求被拦截、验证，并设置了所需的 CORS 响应标头。</p>
<p>为了启用跨域请求（即 Origin 标头存在且与请求的主机不同），您需要有一些显式声明的 CORS 配置。如果未找到匹配的 CORS 配置，则拒绝预检请求。没有将 CORS 标头添加到简单和实际 CORS 请求的响应中，因此浏览器会拒绝它们。</p>
<p>每个 HandlerMapping 都可以使用基于 URL 模式的 CorsConfiguration 映射进行单独配置。在大多数情况下，应用程序使用 MVC Java 配置或 XML 命名空间来声明此类映射，这会导致将单个全局映射传递给所有 HandlerMappping 实例。</p>
<p>您可以将 HandlerMapping 级别的全局 CORS 配置与更细粒度的处理程序级别 CORS 配置相结合。例如，带注释的控制器可以使用类或方法级别的 @CrossOrigin 注释（其他处理程序可以实现 CorsConfigurationSource）。</p>
<p>结合全局和局部配置的规则一般是相加的 —— 例如，所有全局和所有本地起源。对于那些只能接受单个值的属性，例如allowCredentials 和 maxAge，本地覆盖全局值。有关更多详细信息，请参阅 CorsConfiguration#combine(CorsConfiguration)。</p>
<h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><p>允许自定义处理程序执行链的工作流接口。应用程序可以为某些处理程序组注册任意数量的现有或自定义拦截器，以添加常见的预处理行为，而无需修改每个处理程序实现。<br>HandlerInterceptor 在适当的 HandlerAdapter 触发处理程序本身的执行之前被调用。这种机制可以用于预处理方面的大领域，例如用于授权检查或常见的处理程序行为，如语言环境或主题更改。它的主要目的是允许分解出重复的处理程序代码。</p>
<p>在异步处理场景中，处理程序可能会在单独的线程中执行，而主线程退出而不呈现或调用 postHandle 和 afterCompletion 回调。当并发处理程序执行完成时，请求被分派回来以继续渲染模型，并再次调用此合约的所有方法。有关更多选项和详细信息，请参阅 org.springframework.web.servlet.AsyncHandlerInterceptor</p>
<p>通常每个 HandlerMapping bean 定义一个拦截器链，共享它的粒度。为了能够将某个拦截器链应用于一组处理程序，需要通过一个 HandlerMapping bean 映射所需的处理程序。</p>
<p>拦截器本身被定义为应用程序上下文中的 bean，映射 bean 定义通过其“拦截器”属性（在 XML 中：<ref> 的 <list>）引用。</p>
<p>HandlerInterceptor 基本上类似于 Servlet 过滤器，但与后者相反，它只允许自定义预处理和禁止执行处理程序本身的选项，以及自定义后处理。过滤器更强大，例如它们允许交换传递给链的请求和响应对象。请注意，过滤器在 web.xml 中配置，即应用程序上下文中的 HandlerInterceptor。</p>
<p>作为基本准则，与细粒度处理程序相关的预处理任务是 HandlerInterceptor 实现的候选对象，尤其是分解出的公共处理程序代码和授权检查。另一方面，过滤器非常适合请求内容和视图内容处理，例如多部分表单和 GZIP 压缩。这通常显示何时需要将过滤器映射到某些内容类型（例如图像）或所有请求。</p>
<p>WebMvcConfigurer</p>

                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Spring/Spring%20Initialization/">Spring Initialization</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-08-01</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Spring/">Spring</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContextInitializer</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The context may or may not yet be refreshed. If it (a) is an implementation of ConfigurableWebApplicationContext and (b) has not already been refreshed (the recommended approach), then the following will occur:</span><br><span class="line">If the given context has not already been assigned an id, one will be assigned to it</span><br><span class="line">ServletContext and ServletConfig objects will be delegated to the application context</span><br><span class="line">customizeContext will be called</span><br><span class="line">Any ApplicationContextInitializer org.springframework.context.ApplicationContextInitializer ApplicationContextInitializers specified through the &quot;contextInitializerClasses&quot; init-param will be applied.</span><br><span class="line">refresh() will be called</span><br></pre></td></tr></table></figure>

<img src="D:\Markdown 目录\Markdown 文档\工作\Spring\img-assets\image-20210801120000817.png" alt="image-20210801120000817" style="zoom:200%;" />


                
            </div>
        </article>
    
        <article class="post-abstract">
            <div class="post-title">
                <h2><a class="post-title-link" href="/Spring/Spring%20%E4%BA%8B%E5%8A%A1/">Spring 事务</a></h2>
            </div>
            <div class="post-meta">
                <span class="post-time">2021-07-25</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/categories/Spring/">Spring</a>
                    
                </span>
                
            </div>
            <div class="post-content">
                
                    <h2 id="一些简称或术语"><a href="#一些简称或术语" class="headerlink" title="一些简称或术语"></a>一些简称或术语</h2><p><strong>JTA</strong>  Java Transaction API</p>
<p><strong>EJB</strong>   Enterprise Java Beans</p>
<p><strong>CMT</strong> Container Managed Transaction</p>
<p>*<em>JMS *</em>   Java Message Service</p>
<p>*<em>JCA *</em>   Java EE Connector Architecture</p>
<p><strong>weave</strong> byte code modifition 字节码修改来增强类，提供切面，与基于代理的切面是完全不同的一种方式</p>
<h2 id="Spring-框架的事务抽象"><a href="#Spring-框架的事务抽象" class="headerlink" title="Spring 框架的事务抽象"></a>Spring 框架的事务抽象</h2><h3 id="TransactionManager"><a href="#TransactionManager" class="headerlink" title="TransactionManager"></a>TransactionManager</h3><p><code>TransactionManager</code>:  定义事务策略，例如，用于命令式事务管理的 <code>org.springframework.transaction.PlatformTransactionManager</code> 接口或者用于响应式事务管理的 <code>org.springframework.transaction.ReactiveTransactionManager</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p><code>TransactionDefinition</code>: 定义事务的传播行为、隔离级别、超时时间、只读状态</p>
<p>传播行为(Propagation): </p>
<p>隔离级别(Isolation):</p>
<p>超时时间(Timeout):</p>
<p>只读状态(read-only):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_READ_COMMITTED;</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_REPEATABLE_READ;</span></span><br><span class="line">	<span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_SERIALIZABLE;</span></span><br><span class="line">	<span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> PROPAGATION_REQUIRED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ISOLATION_DEFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> TIMEOUT_DEFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> TransactionDefinition <span class="title">withDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p><code>TransactionStatus</code> ：为使用事务性的代码来控制事务的执行和查询事务状态提供了一种简单的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">TransactionExecution</span>, <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h2><p> While the Spring default behavior for declarative transaction management follows EJB convention (roll back is automatic only on unchecked exceptions), it is often useful to customize this behavior.</p>
<h3 id="Using-Transactional"><a href="#Using-Transactional" class="headerlink" title="Using @Transactional"></a>Using @Transactional</h3><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations</a></p>
<blockquote>
<p>You can apply the <code>@Transactional</code> annotation to an interface definition, a method on an interface, a class definition, or a public method on a class. However, the mere presence of the <code>@Transactional</code> annotation is not enough to activate the transactional behavior. The <code>@Transactional</code> annotation is merely metadata that can be consumed by some runtime infrastructure that is <code>@Transactional</code>-aware and that can use the metadata to configure the appropriate beans with transactional behavior. In the preceding example, the <code>&lt;tx:annotation-driven/&gt;</code> element switches on the transactional behavior.</p>
</blockquote>
<p><code>@Transactional</code> 注解只是配置事务行为的元数据，并不会激活这些事务行为，Spring 的事务框架会使用这些元数据为某些 bean 配置它们的事务行为，xml 文件中的 <code>&lt;tx:annotation-driven/&gt;</code> 和配置类（<code>@Configuration</code>）上的 <code>@EnableTransactionManagement</code>注解会激活这些事务行为。</p>
<blockquote>
<p><code>@EnableTransactionManagement</code> and <code>&lt;tx:annotation-driven/&gt;</code> looks for <code>@Transactional</code> only on beans in the same application context in which they are defined. This means that, if you put annotation-driven configuration in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>, it checks for <code>@Transactional</code> beans only in your controllers and not your services. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet" target="_blank" rel="noopener">MVC</a> for more information.</p>
</blockquote>
<p><code>@EnableTransactionManagement</code> and <code>&lt;tx:annotation-driven/&gt;</code> 只会在定义它们本身的上下文中寻找 <code>@Transactional</code> 注解的 bean， 如果是在 Web 应用的 <code>DispatcherServlet</code> 对应的 <code>WebApplicationContext</code> <code>@EnableTransactionManagement</code> and <code>&lt;tx:annotation-driven/&gt;</code>只会在这个上下文中查找，这个上下文一般只会定义控制器以及试图解析器等 web 组件，而不是 service 类。</p>
<blockquote>
<p>In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with <code>@Transactional</code>. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code (that is, <code>@PostConstruct</code>).</p>
</blockquote>
<p>由于 Spring 事务是基于代理的，只有通过代理的外部方法调用才会被拦截，目标对象内部的方法调用（一个方法调用对象内部的另一个方法）是不会在运行时导致一个实际的事务发生的；另外，必须完全初始化代理以提供预期的行为，因此不应在初始化代码（即@PostConstruct）中依赖此功能。</p>
<blockquote>
<p>Consider using of AspectJ mode (see the <code>mode</code> attribute in the following table) if you expect self-invocations to be wrapped with transactions as well. In this case, there no proxy in the first place. Instead, the target class is woven (that is, its byte code is modified) to turn <code>@Transactional</code> into runtime behavior on any kind of method.</p>
</blockquote>
<p>如果想要实现内部调用的事务行为，可以考虑基于 AspectJ 的 AOP, 首先，不会有代理，目标类被编织以将 <code>@Transactional</code> 的运行时行为应用于任何方法上</p>
<p><strong>使用基于代理的事务的 proxy 类型</strong></p>
<ul>
<li><p>class-based proxies </p>
</li>
<li><p>standard JDK interface-based proxies （default or omitted）</p>
</li>
</ul>
<h4 id="Transactional-settings"><a href="#Transactional-settings" class="headerlink" title="@Transactional settings"></a>@Transactional settings</h4><p>默认的<code>@Transactional</code> 的设置：</p>
<ul>
<li><p>The propagation setting is <code>PROPAGATION_REQUIRED.</code> #  默认的传播行为</p>
</li>
<li><p>The isolation level is <code>ISOLATION_DEFAULT.</code> # 默认的事务隔离级别</p>
</li>
<li><p>The transaction is read-write. # 模式是读-写的事务</p>
</li>
<li><p>The transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported. # 超时时间</p>
</li>
<li><p>Any <code>RuntimeException</code> triggers rollback, and any checked <code>Exception</code> does not. # 触发回滚的规则（异常类别）</p>
<p>fully-qualified class name </p>
</li>
</ul>
<h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><h3 id="使用-TransactionTemplate"><a href="#使用-TransactionTemplate" class="headerlink" title="使用 TransactionTemplate"></a>使用 TransactionTemplate</h3><p><code>TransactionTemplate</code> 和 Spring 中其他模板类相似（如 <code>JdbcTemplate</code>），目的是为了减少应用代码中获取和释放事务相关资源的样板式代码</p>
<p>（boilerplate acquisition and release transactional resources），这样应用就可以将关注点放在业务逻辑上。它使用一个回调方法。</p>
<p>应用代码必须执行在一个事务上下文（transactional context）中,  并且使用 <code>TransactionTemplate</code>，仅需两个步骤：</p>
<ol>
<li>应用代码编写  <code>TransactionCallback</code> 实现，这个实现中包含了事务要包含的所有的操作，通常是匿名内部类的形式 。</li>
<li>回调类实现的实例传入 <code>TransactionTemplate.execute(CallBack)</code> 方法中</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleService</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// single TransactionTemplate shared amongst all methods in this instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use constructor-injection to supply the PlatformTransactionManager</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleService</span><span class="params">(PlatformTransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionTemplate = <span class="keyword">new</span> TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">someServiceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback() &#123;</span><br><span class="line">            <span class="comment">// the code in this method executes in a transactional context</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                <span class="keyword">return</span> resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无返回的事务可以实现 <code>TransactionCallbackWithoutResult</code> 接口</p>
<p>事务的属性，如传播行为、隔离级别等可以通过  <code>TransactionTemplate</code> 提供的方法设置（程序中或XML中） </p>
<blockquote>
<p>Code within the callback can roll the transaction back by calling the <code>setRollbackOnly()</code> method on the supplied <code>TransactionStatus</code> object, as follows:</p>
</blockquote>
<p>也可以在回调方法中，调用 <code>TransactionStatus.setRollbackOnly()</code> 回滚事务,  这里取决于是否是新事务，来决定是否直接回滚。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SomeBusinessException ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="使用-PlatformTransactionManager"><a href="#使用-PlatformTransactionManager" class="headerlink" title="使用 PlatformTransactionManager"></a>使用 PlatformTransactionManager</h3><p>也可以提直接使用 <code>PlatformTransactionManager</code> 来管理事务，需要结合 Spring 事务抽象的其它对象： <code>TransactionDefinition</code>, <code>TransactionStatus</code>。 可以实现事务的初始化、回滚和提交。编程式事务也可以显示设置事务的名称，声明式的事务名称一般都是默认的全限定类名+方法名。</p>
<p>Java </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line"><span class="comment">// explicitly setting the transaction name is something that can be done only programmatically</span></span><br><span class="line">def.setName(<span class="string">"SomeTxName"</span>);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// execute your business logic here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure>



<p>在 <code>PlatformTransactionManager.rollback(TransactionStatus status)</code> 方法有如下的注释：</p>
<blockquote>
<p>Do not call rollback on a transaction if commit threw an exception. The transaction will already have been completed and cleaned up when commit  returns, even in case of a commit exception. Consequently, a rollback call after commit failure will lead to an IllegalTransactionStateException.</p>
</blockquote>
<p>不要在commit 时异常后进行回滚，commit 返回时（即使有提交异常），事务已经完成并且已经被清理。所以这时，如果调用 rollback 操作，会导致一个 <code>IllegalTransactionStateException</code>， 这也是上述示例代码中 commit 放在最后的原因</p>
<blockquote>
<p>If the transaction wasn’t a new one, omit the commit for proper participation in the surrounding transaction.</p>
</blockquote>
<p><strong>当调用了 commit 后，如果该事务不是一个新事务，则会忽略提交以正确参与周围的事务中。</strong></p>
<h2 id="Spring-事务的传播行为"><a href="#Spring-事务的传播行为" class="headerlink" title="Spring 事务的传播行为"></a>Spring 事务的传播行为</h2><p>具体的传播行为定义见 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation" target="_blank" rel="noopener">Spring Transaction Propagation</a> 和 <a href="https://blog.csdn.net/soonfly/article/details/70305683" target="_blank" rel="noopener">CSDN-事务属性之7种传播行为</a>，不再赘述. 这里主要是对如何在 Spring 中验证这些传播行为的行为进行验证和说明:</p>
<p>假设想对 <code>PROPAGATION_NESTED</code> 嵌套事务传播行为进行验证, 首先需要设置对应的 TransactionManager 支持:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager dataSourceTransactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">    dataSourceTransactionManager.setNestedTransactionAllowed(<span class="keyword">true</span>); <span class="comment">// 允许嵌套事务</span></span><br><span class="line">    <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>PROPAGATION_NESTED</code> 这种传播行为只会有一个物理事务, 通过多个保存点的机制, 可以使得嵌套的内部事务实现部分回滚, 而不影响外部事务的回滚状态, 只不过时有些操作被回滚了.</strong></p>
<h3 id="错误的验证方式"><a href="#错误的验证方式" class="headerlink" title="错误的验证方式"></a>错误的验证方式</h3><p>接下来,可能想当然的在一个 Service 类中定义如下两个事务方法, 并指定事务的传播行为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 注入对应 DAO 类,进行实际的数据库访问</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LearnSqlMapper sqlMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 第一个事务性的方法, 使用默认的传播行为,即 REQUIRED, 不存在事务时会创建一个新的事务.</span></span><br><span class="line"><span class="comment">    * 在当前方法中会调用第二个事务性方法,它的传播行为为 NESTED </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTXBusiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName());</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">        sqlMapper.insertToUserInfo(Collections.singletonList(userInfo));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用第二个事务性的方法</span></span><br><span class="line">        innerTXBusiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 第二个事务性的方法, 传播行为指定为 NESTED, 期望以一个嵌套子事务(逻辑事务)运行在已经存在的事务中 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.NESTED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerTXBusiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"innerTXBusiness:"</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">        List&lt;UserInfo&gt; userInfos = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        userInfos.forEach(System.out::println);</span><br><span class="line">        sqlMapper.insertToUserInfo(userInfos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里抛出一个 DataAccessException 或其它 RuntimeExcpetion 期望进行此嵌套子事务可以回滚到 savepoint</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadSqlGrammarException(<span class="string">"task"</span>, <span class="string">"sql"</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当在其它的 bean 中调用 <code>TransactionTestService</code> bean 的 <code>outerTXBusiness</code> 方法时, 会发现 <code>outerTXBusiness</code> 和  <code>innerTXBusiness</code> 中所有的操作都被回滚了, 不是预期的 <code>NESTED</code> 传播行为 (内部的嵌套子事务的回滚, 只是回滚到执行前的一个 savepoint, 并不会导致整个事务回滚), 预期中, <code>outerTXBusiness</code> 中的插入数据库操作不会被回滚的.</p>
<p>造成这种现象的原因其实也很简单, 因为 <code>innerTXBusiness</code> 方法根本没有被应用事务的切面通知 (advice, 或者说拦截), 因为属于方法内部调用, 基于代理的 Spring AOP 是不会对这种内部调用应用事务通知的 (Spring 事务是基于 AOP 的).</p>
<h3 id="正确的验证方式"><a href="#正确的验证方式" class="headerlink" title="正确的验证方式"></a>正确的验证方式</h3><p>要进行验证, 可以使用三种方式: </p>
<ol>
<li>切换 Spring AOP 使用 AspectJ 集成 (方法内的调用可以被拦截),</li>
<li>继续使用基于代理的 Spring AOP, 将这两个事务性的方法声明在不同的 bean 中</li>
<li>继续使用基于代理的 Spring AOP, 使用编程式的事务管理</li>
</ol>
<p>第一种就不做尝试了, 看下后面两种的实现:</p>
<h4 id="将这两个事务性的方法声明在不同的-bean-中"><a href="#将这两个事务性的方法声明在不同的-bean-中" class="headerlink" title="将这两个事务性的方法声明在不同的 bean 中"></a>将这两个事务性的方法声明在不同的 bean 中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TX1Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LearnSqlMapper sqlMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TX2Service tx2Service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerTXBusiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName());</span><br><span class="line">        sqlMapper.insertToUserInfo(Collections.singletonList(userInfo));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用第二个事务性方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tx2Service.innerTXBusiness();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"e from innerTXBusiness:"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TX2Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LearnSqlMapper sqlMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定传播行为为 NESTED</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.NESTED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerTXBusiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfos = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        userInfos.forEach(System.out::println);</span><br><span class="line">        sqlMapper.insertToUserInfo(userInfos);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 抛出异常, 验证嵌套子事务回滚到 savepoint 的情况</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"RuntimeException from outerTXBusiness"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当在其它 bean 中 调用 <code>TX1Service#outerTXBusiness()</code> 时, 可以看到正确的行为, 即  <code>TX2Service#innerTXBusiness()</code> 中的操作被回滚,  <code>TX1Service#outerTXBusiness()</code> 中的插入成功, 并没有影响外部事务的操作.</p>
<p><img src="https://raw.githubusercontent.com/weirdWimp/blog-store/main/img/image-20210725142848456.png" alt="image-20210725142848456"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2021-07-25 14:20:45.701 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Creating new transaction with name [com.example.springboot.demo.service.impl.TX1Service.outerTXBusiness]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">2021-07-25 14:20:45.702 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Acquired Connection [com.mysql.jdbc.JDBC4Connection@74367762] for JDBC transaction</span><br><span class="line">2021-07-25 14:20:45.704 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Switching JDBC Connection [com.mysql.jdbc.JDBC4Connection@74367762] to manual commit</span><br><span class="line">2021-07-25 14:20:45.873 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &#x3D;&#x3D;&gt;  Preparing: insert into user_info (uid, name) values (?, ?) </span><br><span class="line">2021-07-25 14:20:45.888 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &#x3D;&#x3D;&gt; Parameters: 882-12-3146(String), Mr. Boris Swaniawski(String)</span><br><span class="line">2021-07-25 14:20:45.893 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &lt;&#x3D;&#x3D;    Updates: 1</span><br><span class="line">2021-07-25 14:20:45.894 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Creating nested transaction with name [com.example.springboot.demo.service.impl.TX2Service.innerTXBusiness]</span><br><span class="line">UserInfo&#123;id&#x3D;0, uid&#x3D;&#39;120-27-6630&#39;, name&#x3D;&#39;Joanne Greenfelder&#39;&#125;</span><br><span class="line">UserInfo&#123;id&#x3D;0, uid&#x3D;&#39;874-91-6406&#39;, name&#x3D;&#39;Dr. Conrad Hessel&#39;&#125;</span><br><span class="line">UserInfo&#123;id&#x3D;0, uid&#x3D;&#39;122-56-3491&#39;, name&#x3D;&#39;Brittni Emmerich&#39;&#125;</span><br><span class="line">UserInfo&#123;id&#x3D;0, uid&#x3D;&#39;360-27-3198&#39;, name&#x3D;&#39;Dr. Damien Conroy&#39;&#125;</span><br><span class="line">2021-07-25 14:20:45.915 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &#x3D;&#x3D;&gt;  Preparing: insert into user_info (uid, name) values (?, ?) , (?, ?) , (?, ?) , (?, ?) </span><br><span class="line">2021-07-25 14:20:45.915 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &#x3D;&#x3D;&gt; Parameters: 120-27-6630(String), Joanne Greenfelder(String), 874-91-6406(String), Dr. Conrad Hessel(String), 122-56-3491(String), Brittni Emmerich(String), 360-27-3198(String), Dr. Damien Conroy(String)</span><br><span class="line">2021-07-25 14:20:45.921 DEBUG 5248 --- [nio-8080-exec-1] c.e.s.d.m.L.insertToUserInfo             : &lt;&#x3D;&#x3D;    Updates: 4</span><br><span class="line">2021-07-25 14:20:45.921 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Rolling back transaction to savepoint</span><br><span class="line">2021-07-25 14:20:45.923 ERROR 5248 --- [nio-8080-exec-1] c.e.s.demo.service.impl.TX1Service       : e from innerTXBusiness:RuntimeException from outerTXBusiness</span><br><span class="line">2021-07-25 14:20:45.923 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Initiating transaction commit</span><br><span class="line">2021-07-25 14:20:45.923 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Committing JDBC transaction on Connection [com.mysql.jdbc.JDBC4Connection@74367762]</span><br><span class="line">2021-07-25 14:20:45.928 DEBUG 5248 --- [nio-8080-exec-1] o.s.j.d.DataSourceTransactionManager     : Releasing JDBC Connection [com.mysql.jdbc.JDBC4Connection@74367762] after transaction</span><br></pre></td></tr></table></figure>





<h4 id="通过代码显示控制事务的执行"><a href="#通过代码显示控制事务的执行" class="headerlink" title="通过代码显示控制事务的执行"></a>通过代码显示控制事务的执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LearnSqlMapper sqlMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerBiz1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName());</span><br><span class="line">        sqlMapper.insertToUserInfo(Collections.singletonList(userInfo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerBiz2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadSqlGrammarException(<span class="string">"task"</span>, <span class="string">"sql"</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerBiz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;UserInfo&gt; userInfos = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">                .mapToObj(i -&gt; <span class="keyword">new</span> UserInfo(FakerUtil.getRandomId(), FakerUtil.getRandomName()))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        userInfos.forEach(System.out::println);</span><br><span class="line">        sqlMapper.insertToUserInfo(userInfos);</span><br><span class="line">        <span class="comment">// throw new BadSqlGrammarException("task", "sql", null);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过显示的代码来控制事务的执行，来验证事务的传播行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nestedTXTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TransactionDefinition outerTXDef = createTXDefinition(<span class="string">"OuterTX"</span>, TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        TransactionStatus outerStatus = transactionManager.getTransaction(outerTXDef);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            txExecute(outerStatus, () -&gt; &#123;</span><br><span class="line">                outerBiz1();</span><br><span class="line"></span><br><span class="line">                innerTXOperation();</span><br><span class="line"></span><br><span class="line">                outerBiz2();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"OuterTX exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">innerTXOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TransactionDefinition innerTXDef = createTXDefinition(<span class="string">"InnerTX"</span>, TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line">        TransactionStatus innerStatus = transactionManager.getTransaction(innerTXDef);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            innerBiz();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage() + <span class="string">" from innerTXOperation"</span>);</span><br><span class="line">            transactionManager.rollback(innerStatus);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当调用了 commit 后，如果该事务不是一个新事务，则会忽略提交以正确参与周围的事务中</span></span><br><span class="line">        transactionManager.commit(innerStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">TXOperation</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">txExecute</span><span class="params">(TransactionStatus status, TXOperation txOperations)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            txOperations.apply();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当调用了 commit 后，如果该事务不是一个新事务，则会忽略提交以正确参与周围的事务中</span></span><br><span class="line">        <span class="comment">// 所以按照模板式的使用就可以了，不必关心如何参与到已经存在的事务中，只需要定义正确的 TransactionDefinition (包括传播行为，隔离级别等)</span></span><br><span class="line">        transactionManager.commit(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionDefinition <span class="title">createTXDefinition</span><span class="params">(String name, <span class="keyword">int</span> propagation)</span> </span>&#123;</span><br><span class="line">        DefaultTransactionDefinition definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        definition.setName(name);</span><br><span class="line">        definition.setPropagationBehavior(propagation);</span><br><span class="line">        definition.setIsolationLevel(TransactionDefinition.ISOLATION_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>[1] <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#tx-propagation" target="_blank" rel="noopener">Data Access (spring.io)</a></p>
<p>[2] <a href="https://blog.csdn.net/soonfly/article/details/70305683" target="_blank" rel="noopener">CSDN-事务的传播行为</a></p>

                
            </div>
        </article>
    
</div>
<div class="paginator">
    
        
        <a class="prev" href="/page/5/">
            <i class="iconfont icon-prev"></i>
            Prev
        </a>
        
        
        <a class="next" href="/page/7/">
            Next
            <i class="iconfont icon-next"></i>
        </a>
        
    
</div>

    </div>
</div>
<footer class="footer-social">
    
    <a class="social-link" target="_blank" href="https://github.com/weirdwimp">
        <i class="iconfont icon-github"></i>
    </a>
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
            2022
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin"></a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
